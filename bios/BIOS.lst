     1 			;***********************************************************************
     2 			;
     3 			; BASIC INPUT/OUTPUT SYSTEM FOR THE DPC BASED AROUND THE INTEL 8080
     4 			; MICRO-PROCESSOR. THIS PROVIDES THE VERY BASIC ROUTINES FOR
     5 			; INTERFACING WITH THE ENVIRONMENT. THIS INCLUDES KEYBOARD INPUT,
     6 			; TEXT AND GRAPHICS DISPLAY, MEMORY PAGING, AND DISK I/O.
     7 			; THERE IS NO SECONDARY PROCESSOR TO HANDLE I/O, AS I AM SHOOTING FOR
     8 			; SIMPLICITY NOT PERFORMANCE.
     9 			;
    10 			;***********************************************************************
    11
    12 			;***********************************************************************
    13 			;
    14 			; REGISTERS ARE SAVED BY THE CALLER. THE CALLER ONLY NEEDS TO SAVE
    15 			; REGISTERS THAT IT SEES FIT.
    16 			;
    17 			; ALL REGISTERS MAY BE USED BY THE CALLEE
    18 			;
    19 			; ARGS ARE PASSED THROUGH REGISTERS AND ON TOP OF STACK
    20 			; (MOST 8-BIT VALUES ARE RETURNED THROUGH A AND 16-BIT VALUES IN HL)
    21 			;
    22 			; THE CALLEE IS RESPONSIBLE FOR STACK CLEAN UP
    23 			;
    24 			;***********************************************************************
    25
    26     			include "HDD.INC"
     1
     2 			;******************************************************************************
     3 			;
     4 			; HDD COMMANDS
     5 			;
     6 			;******************************************************************************
     7
     8      00 01		ENTER_IDLE	EQU	001H	; FORCES CPU INTO IDLE STATE, MAY RESPOND WITH ERROR
     9      00 02		REQUEST_WRITE	EQU	002H	; REQUESTS TO WRITE, WILL RESPOND WITH ACK IF OKAY
    10      00 03		REQUEST_READ	EQU	003H	; REQUESTS TO READ, WILL RESPOND WITH ACK IF OKAY
    11      00 04		START_FRAME	EQU	004H	; INDICATES THE START OF A DATA FRAME
    12      00 05		END_FRAME	EQU	005H	; INDICATES THE END OF A DATA FRAME
    13      00 06		STATUS		EQU	006H	; WILL RETURN THE STATUS OF THE DISK.
    14 							; IF THE DISK IS NOT IDLE OR WAITING, AN ERROR WILL RETURN
    15
    16 			;******************************************************************************
    17 			;
    18 			; HDD RESPONSES
    19 			;
    20 			;******************************************************************************
    21
    22      00 07		ACKNOWLEDGE	EQU	007H	; RESPONSE TO ACKOWLEDGE A READ/WRITE REQUEST
    23      00 08		WRITE_OKAY	EQU	008H	; SENT AFTER RECIEVING AN END_FRAME IF THE WRITE WAS SUCCESSFUL
    24      00 09		READ_OKAY	EQU	009H	; SENT AFTER RECIEVING AN ACK AFTER THE END FRAME OF A READ
    25      00 F0		WRITE_ERROR	EQU	0F0H	; OCCURS IF AN END_FRAME IS NOT SENT AFTER THE DATA FRAME
    26      00 F1		READ_ERROR	EQU	0F1H	; OCCURS IF AN END_FRAME IS NOT SENT AFTER THE ADDRESS, OR AN ACK IS NOT SENT AFTER THE DATA OR THE CPU ATTEMPTS TO SEND DATA DURING A READ OPERATION
    27      00 F2		NACK_ERROR	EQU	0F2H	; OCCURS IF A COMMAND IS NOT RECOGNIZED FROM THE IDLE STATE
    28      00 F3		PROC_ERROR	EQU	0F3H	; OCCURS IF THE COMMAND IS NOT RECOGNIZED FROM A WAITING STATE
    29
    30 			;******************************************************************************
    31 			;
    32 			; HDD STATUSES
    33 			;
    34 			;******************************************************************************
    35
    36      00 01		IDLE		EQU	001H	; DISK IS DOING NOTHING
    37      00 02		WRITE_PROC	EQU	002H	; DISK IS IN A WRITE PROCESS, EXPECTING DATA FROM CPU
    38      00 04		READ_PROC	EQU	004H	; DISK IS IN A READ PROCESS, SENDING DATA TO CPU
    39      00 08		WAITING 	EQU	008H	; DISK IS WAITING FOR A START FRAME OR IDLE COMMAND
    40
    41 			;******************************************************************************
    42 			;
    43 			; POTENTIAL HDD ERROR CONDITIONS
    44 			;
    45 			;******************************************************************************
    46
    47      00 E0		HDD_REFUSE_IDLE EQU	0E0H	; OCCURS WHEN THE DISK WILL NOT ENTER AN IDLE STATE; LIKELY THE DISK IS FAULTY
    27     			include "BIOS_MAP.INC"
     1 			;***********************************************************************
     2 			;
     3 			; ADDRESS MACROS FOR BIOS
     4 			;
     5 			;***********************************************************************
     6
     7      00 00		BIOS_BASE	  EQU 0000H
     8      04 00		BIOS_SIZE	  EQU 0400H
     9
    10      04 00		BIOS_VAR_BASE	  EQU BIOS_BASE + BIOS_SIZE
    11      00 80		BIOS_VAR_SIZE	  EQU 0080H
    12
    13      04 80		INPUT_BUFFER_BASE EQU BIOS_VAR_BASE + BIOS_VAR_SIZE
    14      01 00		INPUT_BUFFER_SIZE EQU 0100H
    15
    16      01 00		SYS_STACK_SIZE	  EQU 00100H
    17      06 80		SYS_STACK_BASE	  EQU INPUT_BUFFER_BASE+INPUT_BUFFER_SIZE+SYS_STACK_SIZE
    18
    19      06 81		VIDEO_MEMORY_BASE EQU SYS_STACK_BASE+1
    20      50 00		VIDEO_MEMORY_SIZE EQU 5000H
    21
    22      56 81		OS_LOADER_BASE	  EQU VIDEO_MEMORY_BASE+VIDEO_MEMORY_SIZE
    23      02 00		OS_LOADER_SIZE	  EQU 0200H
    24
    25      58 81		BIOS_EXTENTION	  EQU OS_LOADER_BASE+OS_LOADER_SIZE
    28
    29 			;***********************************************************************
    30 			;
    31 			; PORT MACROS FOR I/O OPERATIONS
    32 			;
    33 			;***********************************************************************
    34
    35      00 01		VIDEO_MODE_PORT EQU 01H
    36      00 02		TEXT_OPER_PORT	EQU 02H
    37      00 03		TEXT_OUT_PORT	EQU 03H
    38
    39      00 04		KEY_INPUT_PORT	EQU 04H
    40
    41      00 05		HDD_RX_PORT	EQU 05H
    42      00 06		HDD_TX_PORT	EQU 06H
    43
    44      00 0A		BANK_PORT	EQU 0AH
    45
    46 			;***********************************************************************
    47 			;
    48 			; HARD DRIVE STATUS MACROS
    49 			;
    50 			;***********************************************************************
    51
    52      00 00		HDD_IDLE	EQU 000H    ; HARD DRIVE IS IDLING
    53      00 FF		HDD_CMD_ERROR	EQU 0FFH    ; INVALID ADDRESS
    54      00 01		HDD_NEED_DATA	EQU 001H    ; WAITING FOR BYTE
    55      00 FE		HDD_WRITE_ERROR EQU 0FEH    ; WRITING ERROR
    56      00 02		HDD_HAVE_DATA	EQU 002H    ; WAITING FOR CPU TO READ BYTE
    57      00 FD		HDD_READ_ERROR	EQU 0FDH    ; READING ERROR
    58      00 03		HDD_WRITE_DONE	EQU 003H    ; WRITE IS DONE
    59      00 04		HDD_READ_DONE	EQU 004H    ; READ IS DONE
    60
    61 			;***********************************************************************
    62 			;
    63 			; HARD DRIVE COMMANDS
    64 			;
    65 			;***********************************************************************
    66
    67      00 00		HDD_ENTER_IDLE	EQU 000H    ; FORCES IDLE
    68      00 01		HDD_START_WRITE EQU 001H    ; STARTS WRITING SECTOR TO ADDRESS
    69      00 FE		HDD_END_WRITE	EQU 0FEH    ; TERMINATES WRITE
    70      00 02		HDD_START_READ	EQU 002H    ; STARTS READING SECTOR
    71      00 FD		HDD_END_READ	EQU 0FDH    ; TERMINATES READ
    72      00 03		HDD_READ_BYTE	EQU 003H    ; SIGNALS HARD DISK TO READ THE NEXT BYTE
    73      00 04		HDD_SEND_BYTE	EQU 004H    ; SIGNALS HARD DISK TO SEND THE NEXT BYTE
    74
    75 			;***********************************************************************
    76 			;
    77 			; KEYBOARD MACROS
    78 			;
    79 			;***********************************************************************
    80
    81      00 00		TRIGGER_RETURN	EQU 00H
    82      00 01		TRIGGER_KEYDOWN EQU 01H
    83
    84      00 00		POLLING_MODE	EQU 00H
    85      00 01		INTERRUPT_MODE	EQU 01H
    86
    87 			;***********************************************************************
    88 			;
    89 			; VIDEO MACROS
    90 			;
    91 			;***********************************************************************
    92
    93      00 00		DELETE_CHAR	EQU 00H
    94      00 01		APPEND_CHAR	EQU 01H
    95      00 02		CARIDGE_RETURN	EQU 02H
    96      00 03		LINE_FEED	EQU 03H
    97      00 03		RESET_SCREEN	EQU 03H
    98      00 02		NEW_LINE	EQU 02H
    99
   100      00 00		HI_RES_MODE	EQU 00H
   101      00 01		LO_RES_MODE	EQU 01H
   102      00 02		TEXT_MODE	EQU 02H
   103
   104 			;***********************************************************************
   105 			;
   106 			; NOP FILLS BETWEEN INTERRUPT VECTORS
   107 			; IT'S TOO MUCH WORK TO TRY TO WORK AROUND THEM
   108 			; AND MAKES UGLY CODE
   109 			;
   110 			;***********************************************************************
   111
   112     		INT_FILL_HALF	MACRO
   113     				NOP
   114     				NOP
   115     				NOP
   116     				NOP
   117     				NOP
   118     				NOP
   119     				ENDM
   120
   121
   122     		INT_FILL	MACRO
   123     				INT_FILL_HALF
   124     				INT_FILL_HALF
   125     				NOP
   126     				ENDM
   127
   128
   129 			;***********************************************************************
   130 			;
   131 			; INTERRUPT VECTOR JUMP TABLE
   132 			;
   133 			; BY DEFAULT: 00 - BIOS_START
   134 			;	      08 - ZERO_INPUT_BUFFER
   135 			;	      10 - KEYBOARD_INTERRUPT
   136 			;	      18 -
   137 			;	      20 -
   138 			;	      28 -
   139 			;	      30 -
   140 			;	      38 -
   141 			;
   142 			;***********************************************************************
   143
   144      00 00			ORG BIOS_BASE
   145
   146 0000 C3 10 02		JMP ENTRY
   147
   148     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0003 00				NOP
     3 0004 00				NOP
     4 0005 00				NOP
     5 0006 00				NOP
     6 0007 00				NOP
     7 0008 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0009 00				NOP
     3 000A 00				NOP
     4 000B 00				NOP
     5 000C 00				NOP
     6 000D 00				NOP
     7 000E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 000F 00				NOP
     5 			;\------------- INT_FILL end
   149
   150 0010 C3 8C 00		JMP KEYBOARD_INT
   151
   152     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0013 00				NOP
     3 0014 00				NOP
     4 0015 00				NOP
     5 0016 00				NOP
     6 0017 00				NOP
     7 0018 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0019 00				NOP
     3 001A 00				NOP
     4 001B 00				NOP
     5 001C 00				NOP
     6 001D 00				NOP
     7 001E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 001F 00				NOP
     5 			;\------------- INT_FILL end
   153
   154 0020 C3 7C 00		JMP ZERO_INPUT_BUFFER
   155
   156     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0023 00				NOP
     3 0024 00				NOP
     4 0025 00				NOP
     5 0026 00				NOP
     6 0027 00				NOP
     7 0028 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0029 00				NOP
     3 002A 00				NOP
     4 002B 00				NOP
     5 002C 00				NOP
     6 002D 00				NOP
     7 002E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 002F 00				NOP
     5 			;\------------- INT_FILL end
   157
   158 0030 C3 74 00		JMP SWITCH_BANK
   159
   160     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0033 00				NOP
     3 0034 00				NOP
     4 0035 00				NOP
     5 0036 00				NOP
     6 0037 00				NOP
     7 0038 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0039 00				NOP
     3 003A 00				NOP
     4 003B 00				NOP
     5 003C 00				NOP
     6 003D 00				NOP
     7 003E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 003F 00				NOP
     5 			;\------------- INT_FILL end
   161
   162 0040 C3 73 00		JMP NULL_INTERRUPT
   163
   164     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0043 00				NOP
     3 0044 00				NOP
     4 0045 00				NOP
     5 0046 00				NOP
     6 0047 00				NOP
     7 0048 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0049 00				NOP
     3 004A 00				NOP
     4 004B 00				NOP
     5 004C 00				NOP
     6 004D 00				NOP
     7 004E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 004F 00				NOP
     5 			;\------------- INT_FILL end
   165
   166 0050 C3 73 00		JMP NULL_INTERRUPT
   167
   168     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0053 00				NOP
     3 0054 00				NOP
     4 0055 00				NOP
     5 0056 00				NOP
     6 0057 00				NOP
     7 0058 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0059 00				NOP
     3 005A 00				NOP
     4 005B 00				NOP
     5 005C 00				NOP
     6 005D 00				NOP
     7 005E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 005F 00				NOP
     5 			;\------------- INT_FILL end
   169
   170 0060 C3 73 00		JMP NULL_INTERRUPT
   171
   172     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0063 00				NOP
     3 0064 00				NOP
     4 0065 00				NOP
     5 0066 00				NOP
     6 0067 00				NOP
     7 0068 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0069 00				NOP
     3 006A 00				NOP
     4 006B 00				NOP
     5 006C 00				NOP
     6 006D 00				NOP
     7 006E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 006F 00				NOP
     5 			;\------------- INT_FILL end
   173
   174 0070 C3 73 00		JMP NULL_INTERRUPT
   175
   176
   177 			NULL_INTERRUPT:
   178 0073 C9			RET
   179
   180
   181 			;***********************************************************************
   182 			;
   183 			; FUNCTION:  SWITCH_BANK
   184 			; PARAMS:    BANK NUMBER IN A
   185 			; RETURNS:   NONE
   186 			; NOTES:     SWITCHES THE MEMORY BANK. BE PREPARED.
   187 			; PROC TIME: 20 CYCLES
   188 			;
   189 			;***********************************************************************
   190
   191 			SWITCH_BANK:
   192 0074 D3 0A			OUT BANK_PORT
   193 0076 C9			RET
   194
   195 			;***********************************************************************
   196 			;
   197 			; FUNCTION:  SET_INPUT_MODE
   198 			; PARAMS:    MODE CODE IN A
   199 			; RETURNS:   MODE SENT
   200 			; NOTES:     CHANGES THE INPUT MODE TO EITHER INTERRUPT OR POLLING
   201 			; PROC TIME: 5702 CYCLES
   202 			;
   203 			;***********************************************************************
   204
   205 			SET_INPUT_MODE:
   206 0077 E6 01			ANI  01H
   207 0079 32 01 04		STA  INPUT_MODE
   208
   209
   210 			;***********************************************************************
   211 			;
   212 			; FUNCTION:  ZERO_INPUT_BUFFER
   213 			; PARAMS:    NONE
   214 			; RETURNS:   NONE
   215 			; NOTES:     ZEROS THE BUFFER AND COUNTERS
   216 			; PROC TIME: 5682 CYCLES
   217 			;
   218 			;***********************************************************************
   219
   220 			ZERO_INPUT_BUFFER:
   221 007C AF			XRA  A
   222 007D 32 02 04		STA  BUFFER_INDEX
   223 0080 32 03 04		STA  PROCESSED_INDEX
   224 0083 21 80 04		LXI  H,INPUT_BUFFER
   225 			LOOP_ZERO_BUFFER:
   226 0086 77			MOV  M,A
   227 0087 2C			INR  L
   228 0088 C2 86 00		JNZ  LOOP_ZERO_BUFFER
   229 008B C9			RET
   230
   231 			;***********************************************************************
   232 			;
   233 			; FUNCTION:  KEYBOARD_INT
   234 			; PARAMS:    NONE
   235 			; RETURNS:   KEY PRESSED
   236 			; NOTES:     TRIGGERED WHENEVER A KEY IS PRESSED
   237 			;	     IF IN INTERRUPT MODE, ADDS KEY TO THE BUFFER
   238 			;	     IF IN POLLING MODE, THE STATE OF THE KEY IS TOGGLED
   239 			; PROC TIME: 158-216 CYCLES
   240 			;
   241 			;***********************************************************************
   242
   243 			KEYBOARD_INT:
   244 008C F5			PUSH PSW	     ; ENTER INTERRUPT
   245 008D C5			PUSH B
   246 008E D5			PUSH D
   247 008F E5			PUSH H
   248 0090 21 80 04		LXI  H,INPUT_BUFFER  ; LOAD H WITH BUFFER ADDRESS
   249 0093 3A 01 04		LDA  INPUT_MODE      ; TEST IF WE'RE IN INTERRUPT MODE
   250 0096 B7			ORA  A
   251 0097 CA AE 00		JZ   TOGGLE_STATE    ; IF WE'RE NOT, THEN GO TO POLLING MODE
   252 009A DB 04			IN   KEY_INPUT_PORT  ; IF WE ARE, GET KEY PRESSED
   253 009C FE 80			CPI  10000000B	     ; IF KEY PRESSED > 127 THAN IT'S SIGNALING BEING RELEASED
   254 009E F2 B6 00		JP   EXIT_INTERRUPT  ; WE DON'T RECORD RELEASES IN INTERRUPT MODE SO EXIT
   255 00A1 47			MOV  B,A	     ; IF RECORDING, SAVE CHAR IN B
   256 00A2 3A 02 04		LDA  BUFFER_INDEX    ; LOAD A WITH INDEX
   257 00A5 6F			MOV  L,A	     ; BECAUSE THE BUFFER IS AT 0300H, WE JUST MOVE A INTO L
   258 00A6 3C			INR  A		     ; INCREMENT TO NEXT MEMORY LOCATION
   259 00A7 32 02 04		STA  BUFFER_INDEX    ; STORE MEMORY LOCATION FOR NEXT CALL
   260 00AA 70			MOV  M,B	     ; STORE CHAR
   261 00AB C3 B6 00		JMP  EXIT_INTERRUPT
   262
   263 			TOGGLE_STATE:
   264 00AE DB 04			IN   KEY_INPUT_PORT  ; GET KEY PRESSED
   265 00B0 E6 7F			ANI  01111111B	     ; IGNORE STATE, AS TOGGLING HANDLES THIS
   266 00B2 6F			MOV  L,A
   267 00B3 7E			MOV  A,M
   268 00B4 2F			CMA		     ; TOGGLE KEY STATE
   269 00B5 77			MOV  M,A
   270
   271 			;***********************************************************************
   272 			;
   273 			; FUNCTION:  EXIT_INTERRUPT
   274 			; PARAMS:    NONE
   275 			; RETURNS:   NONE
   276 			; NOTES:     RESTORES THE STATE OF ALL REGISTERS FROM ENTER_INTERRUPT
   277 			; PROC TIME: 50 CYCLES
   278 			;
   279 			;***********************************************************************
   280 			EXIT_INTERRUPT:
   281 00B6 E1			POP  H
   282 00B7 D1			POP  D
   283 00B8 C1			POP  B
   284 00B9 F1			POP  PSW
   285 00BA C9			RET
   286
   287 			;***********************************************************************
   288 			;
   289 			; FUNCTION:  GETKEY
   290 			; PARAMS:    IF IN POLLING MODE, THEN KEY IN A
   291 			;	     IF IN INTERRUPT MODE, THEN NONE
   292 			; RETURNS:   IF IN POLLING MODE, STATE OF KEY IN A
   293 			;	     OTHERWISE NEXT KEY IN BUFFER IN A OR -1 IF NO KEYS PRESSED
   294 			; NOTES:
   295 			; PROC TIME: 62/93 CYCLES
   296 			;
   297 			;***********************************************************************
   298
   299 			GETKEY:
   300 00BB 21 80 04		LXI H,INPUT_BUFFER    ; LOAD HL WITH BUFFER ADDRESS
   301 00BE 47			MOV B,A 	      ; STORE CHAR IN B INCASE WE'RE IN POLLING MODE
   302 00BF 3A 01 04		LDA INPUT_MODE	      ; CHECK IF WE'RE IN INTERRUPT MODE
   303 00C2 B7			ORA A
   304 00C3 CA D8 00		JZ  GET_STATE	      ; IF NOT GO TO GET THE KEY STATE
   305 00C6 3A 03 04		LDA PROCESSED_INDEX   ; LOAD CURRENT INDEX OF PROCESSED KEYS
   306 00C9 6F			MOV L,A 	      ; STORE IN LOWER ADDRESS
   307 00CA 3A 02 04		LDA BUFFER_INDEX      ; LOAD INDEX OF UNPROCESSED KEYS
   308 00CD BD			CMP L
   309 00CE 3E FF			MVI A,0FFH
   310 00D0 C8			RZ		      ; IF WE'RE AT THE SAME INDEX, NO KEYS HAVE BEEN PRESSED
   311 00D1 7D			MOV A,L
   312 00D2 3C			INR A
   313 00D3 32 03 04		STA PROCESSED_INDEX   ; STORE THE NEXT INDEX
   314 00D6 7E			MOV A,M 	      ; LOAD A WITH KEY PRESSED
   315 00D7 C9			RET		      ; GTFO
   316
   317 			GET_STATE:
   318 00D8 68			MOV L,B 	      ; MOVE INDEX OF KEY TO LOWER ADDRESS
   319 00D9 7E			MOV A,M 	      ; GET KEY STATE
   320 00DA C9			RET
   321
   322 			;***********************************************************************
   323 			;
   324 			; FUNCTION:  BACKSPACE
   325 			; PARAMS:    NONE
   326 			; RETURNS:   -1 IF NOT IN TEXT MODE
   327 			; NOTES:     DELETES THE PREVIOUS CHARACTER
   328 			; PROC TIME: 28/59 CYCLES
   329 			;
   330 			;***********************************************************************
   331
   332 			BACKSPACE:
   333 00DB DB 01			IN  VIDEO_MODE_PORT
   334 00DD FE 02			CPI TEXT_MODE
   335 00DF 3E FF			MVI A,0FFH
   336 00E1 C0			RNZ
   337 00E2 3E 00			MVI A,DELETE_CHAR
   338 00E4 D3 02			OUT TEXT_OPER_PORT
   339 00E6 D3 03			OUT TEXT_OUT_PORT
   340 00E8 C9			RET
   341
   342 			;***********************************************************************
   343 			;
   344 			; FUNCTION:  NEWLINE
   345 			; PARAMS:    NONE
   346 			; RETURNS:   -1 IF NOT IN TEXT MODE
   347 			; NOTES:     GOES TO NEXT LINE IN DISPLAY
   348 			; PROC TIME: 28/59 CYCLES
   349 			;
   350 			;***********************************************************************
   351
   352 			NEWLINE:
   353 00E9 DB 01			IN  VIDEO_MODE_PORT
   354 00EB FE 02			CPI TEXT_MODE
   355 00ED 3E FF			MVI A,0FFH
   356 00EF C0			RNZ
   357 00F0 3E 02			MVI A,NEW_LINE
   358 00F2 D3 02			OUT TEXT_OPER_PORT
   359 00F4 D3 03			OUT TEXT_OUT_PORT
   360 00F6 C9			RET
   361
   362 			;***********************************************************************
   363 			;
   364 			; FUNCTION:  RESET_CURSOR
   365 			; PARAMS:    NONE
   366 			; RETURNS:   -1 IN A IF NOT IN TEXT MODE, ELSE NONE
   367 			; NOTES:     SETS CURSOR TO 0
   368 			; PROC TIME: 28/63 CYCLES
   369 			;
   370 			;***********************************************************************
   371
   372 			RESET_CURSOR:
   373 00F7 DB 01			IN  VIDEO_MODE_PORT
   374 00F9 FE 02			CPI TEXT_MODE
   375 00FB 3E FF			MVI A,0FFH
   376 00FD C0			RNZ
   377 00FE 3E 03			MVI A,RESET_SCREEN
   378 0100 D3 02			OUT TEXT_OPER_PORT
   379 0102 AF			XRA A
   380 0103 D3 03			OUT TEXT_OUT_PORT
   381 0105 C9			RET
   382
   383 			;***********************************************************************
   384 			;
   385 			; FUNCTION:  DISPCHAR
   386 			; PARAMS:    CHAR TO DISPLAY IN A
   387 			; RETURNS:   CHAR DISPLAYED OR -1 IF NOT IN TEXT MODE
   388 			; NOTES:     DISPLAYS CHARACTER TO SCREEN AT CURSOR POSITION THEN
   389 			;	     INCREMENTS CURSOR
   390 			; PROC TIME: 45-110 CYCLES
   391 			;
   392 			;***********************************************************************
   393
   394 			DISPCHAR:
   395 0106 FE 08			CPI 08H
   396 0108 CA DB 00		JZ  BACKSPACE
   397 010B FE 0A			CPI 0AH
   398 010D CA E9 00		JZ  NEWLINE
   399 0110 47			MOV B,A
   400 0111 DB 01			IN  VIDEO_MODE_PORT
   401 0113 FE 02			CPI TEXT_MODE
   402 0115 3E FF			MVI A,0FFH
   403 0117 C0			RNZ
   404 0118 3E 01			MVI A,APPEND_CHAR
   405 011A D3 02			OUT TEXT_OPER_PORT
   406 011C 78			MOV A,B
   407 011D D3 03			OUT TEXT_OUT_PORT
   408 011F C9			RET
   409 				
   410 			;***********************************************************************
   411 			;
   412 			; FUNCTION:  GETCHAR
   413 			; PARAMS:    NONE
   414 			; RETURNS:   CHARACTER CODE OF INPUT KEY
   415 			; NOTES:     WAITS FOR A KEY TO GET PRESSED AND DISPLAYS IT TO SCREEN
   416 			; PROC TIME:
   417 			;
   418 			;***********************************************************************	
   419
   420 			GETCHAR:
   421 0120 CD BB 00		CALL GETKEY
   422 0123 FE FF			CPI  0FFH
   423 0125 CA 20 01		JZ   GETCHAR
   424 0128 C3 06 01		JMP  DISPCHAR
   425
   426 			;***********************************************************************
   427 			;
   428 			; FUNCTION:  GETCH
   429 			; PARAMS:    NONE
   430 			; RETURNS:   CHARACTER CODE OF INPUT KEY
   431 			; NOTES:     RETURNS KEY PRESSED WITHOUT ECHO
   432 			; PROC TIME:
   433 			;
   434 			;***********************************************************************
   435
   436 			GETCH:
   437 012B CD BB 00		CALL GETKEY
   438 012E FE FF			CPI  0FFH
   439 0130 CA 2B 01		JZ   GETCH
   440 0133 C9			RET
   441
   442 			;***********************************************************************
   443 			;
   444 			; FUNCTION:  PRINT
   445 			; PARAMS:    BASE OF NULL-TERMINATED STRING IN HL
   446 			; RETURNS:   0 IN A IF SUCCESSFUL
   447 			; NOTES:
   448 			; PROC TIME: 127*(STRLEN+1) + 69
   449 			;
   450 			;***********************************************************************
   451
   452 			PRINT:
   453 0134 7E			MOV  A,M
   454 0135 23			INX  H
   455 0136 CD 06 01		CALL DISPCHAR
   456 0139 B7			ORA  A
   457 013A C2 34 01		JNZ  PRINT
   458 013D C3 DB 00		JMP  BACKSPACE
   459
   460 			;***********************************************************************
   461 			;
   462 			; FUNCTION:  SET_VIDE0_MODE
   463 			; PARAMS:    MODE CODE IN A
   464 			; RETURNS:   MODE SENT IN A
   465 			; NOTES:     CHANGES THE DISPLAY MODE
   466 			; PROC TIME: 27 CYCLES
   467 			;
   468 			;***********************************************************************
   469
   470 			SET_VIDEO_MODE:
   471 0140 E6 03			ANI 011B
   472 0142 D3 01			OUT VIDEO_MODE_PORT
   473 0144 C9			RET
   474
   475 			;***********************************************************************
   476 			;
   477 			; FUNCTION:  HARDWARE_TEST
   478 			; PARAMS:    NONE
   479 			; RETURNS:   0 IF SUCCESSFUL, OTHERWISE ERROR CODE IN A
   480 			; NOTES:     TESTS EVERYTHING EVER.
   481 			; PROC TIME:
   482 			;
   483 			;***********************************************************************
   484
   485 			HARDWARE_TEST:
   486 0145 C9			RET
   487
   488 			;***********************************************************************
   489 			;
   490 			; FUNCTION:  READ_SECTOR
   491 			; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
   492 			; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
   493 			; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
   494 			;				 C C C C C C C H  |  H H S S S S S S
   495 			; PROC TIME: BEST CASE: 30883 CYCLES
   496 			;
   497 			;***********************************************************************
   498
   499 			READ_SECTOR:
   500 0146 F3			DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
   501 0147 3E 06			MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
   502 0149 D3 06			OUT  HDD_TX_PORT
   503 014B DB 05			IN   HDD_RX_PORT
   504 014D FE 01			CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
   505 014F CA 65 01		JZ   READ_SEC00     ; IT IS IDLE, SO PERFORM READ
   506 0152 3E 01			MVI  A,ENTER_IDLE   ; FORCE TO IDLE
   507 0154 D3 06			OUT  HDD_TX_PORT
   508 0156 3E 06			MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
   509 0158 D3 06			OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
   510 015A DB 05			IN   HDD_RX_PORT    ; GET STATUS
   511 015C FE 01			CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
   512 015E CA 65 01		JZ   READ_SEC00     ; CONTINUE
   513 0161 FB			EI		    ; RE-ENABLE INTERRUPTS
   514 0162 3E E0			MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
   515 0164 C9			RET			; RETURN
   516 			READ_SEC00:
   517 0165 3E 03			MVI  A,REQUEST_READ ; REQUEST READ OPERATION
   518 0167 D3 06			OUT  HDD_TX_PORT
   519 0169 DB 05			IN   HDD_RX_PORT    ; GET RESPONSE
   520 016B FE 07			CPI  ACKNOWLEDGE    ; ? - ACK
   521 016D C2 B2 01		JNZ  READ_ERR	    ; N - RETURN
   522 0170 3E 04			MVI  A,START_FRAME  ; SEND A START FRAME
   523 0172 D3 06			OUT  HDD_TX_PORT
   524 0174 7A			MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
   525 0175 D3 06			OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
   526 0177 7B			MOV  A,E	    ; MOVE IN LOWER 8 BITS
   527 0178 D3 06			OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
   528 017A 3E 05			MVI  A,END_FRAME    ; END FRAME
   529 017C D3 06			OUT  HDD_TX_PORT    ; SEND
   530 017E DB 05			IN   HDD_RX_PORT    ;
   531 0180 FE 04			CPI  START_FRAME    ; ? - START FRAME
   532 0182 C2 B2 01		JNZ  READ_ERR	    ; N - RETURN
   533 0185 11 00 02		LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
   534 			READ_SEC10:
   535 0188 DB 05			IN   HDD_RX_PORT    ; READ A BYTE
   536 018A 77			MOV  M,A	    ; STORE BYTE IN BUFFER
   537 018B 23			INX  H		    ; INCREMENT BUFFER PTR
   538 018C 1D			DCR  E		    ; DECREMENT E
   539 018D C2 88 01		JNZ  READ_SEC10     ; RELOOP IF != 0
   540 0190 15			DCR  D		    ; DECREMENT D AS WELL
   541 0191 F2 88 01		JP   READ_SEC10     ; RELOOP IF >= 0
   542 0194 DB 05			IN   HDD_RX_PORT    ; READ WHAT SHOULD BE AN END_FRAME
   543 0196 FE 05			CPI  END_FRAME	    ; ? - WHAT WE EXPECT
   544 0198 C2 B2 01		JNZ  READ_ERR	    ; N - RETURN
   545 019B 3E 07			MVI  A,ACKNOWLEDGE  ; LOAD ACK
   546 019D D3 06			OUT  HDD_TX_PORT    ; SEND ACK
   547 019F DB 05			IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
   548 01A1 FE 09			CPI  READ_OKAY	    ; ENSURE THE READ IS OKAY
   549 01A3 C2 B2 01		JNZ  READ_ERR	    ; RETURN IF NOT
   550 01A6 3E 01			MVI  A,ENTER_IDLE   ;
   551 01A8 D3 06			OUT  HDD_TX_PORT    ; SEND COMMAND TO IDLE
   552 01AA DB 05			IN   HDD_RX_PORT    ; SHOULD RECIEVE IDLE
   553 01AC FE 01			CPI  IDLE	    ; ? - WHAT WE EXPECT
   554 01AE C2 B2 01		JNZ  READ_ERR	    ; N - RETURN EARLY
   555 01B1 AF			XRA  A		    ; ZERO RETURN VALUE
   556 			READ_ERR:
   557 01B2 FB			EI		    ; ENABLE INTERRUPTS
   558 01B3 C9			RET		    ; RETURN
   559
   560 			;***********************************************************************
   561 			;
   562 			; FUNCTION:  WRITE_SECTOR
   563 			; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
   564 			; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
   565 			; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
   566 			;				 C C C C C C C H  |  H H S S S S S S
   567 			; PROC TIME: BEST CASE: 30883 CYCLES
   568 			;
   569 			;***********************************************************************
   570
   571 			WRITE_SECTOR:
   572 01B4 F3			DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
   573 01B5 3E 06			MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
   574 01B7 D3 06			OUT  HDD_TX_PORT
   575 01B9 DB 05			IN   HDD_RX_PORT
   576 01BB FE 01			CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
   577 01BD CA D3 01		JZ   WRITE_SEC00    ; IT IS IDLE, SO PERFORM WRITE
   578 01C0 3E 01			MVI  A,ENTER_IDLE   ; FORCE TO IDLE
   579 01C2 D3 06			OUT  HDD_TX_PORT
   580 01C4 3E 06			MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
   581 01C6 D3 06			OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
   582 01C8 DB 05			IN   HDD_RX_PORT    ; GET STATUS
   583 01CA FE 01			CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
   584 01CC CA D3 01		JZ   WRITE_SEC00    ; CONTINUE
   585 01CF FB			EI		    ; RE-ENABLE INTERRUPTS
   586 01D0 3E E0			MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
   587 01D2 C9			RET			; RETURN
   588 			WRITE_SEC00:
   589 01D3 3E 02			MVI  A,REQUEST_WRITE; REQUEST READ OPERATION
   590 01D5 D3 06			OUT  HDD_TX_PORT
   591 01D7 DB 05			IN   HDD_RX_PORT    ; GET RESPONSE
   592 01D9 FE 07			CPI  ACKNOWLEDGE    ; ? - ACK
   593 01DB C2 0E 02		JNZ  WRITE_ERR	    ; N - RETURN
   594 01DE 3E 04			MVI  A,START_FRAME  ; SEND A START FRAME
   595 01E0 D3 06			OUT  HDD_TX_PORT
   596 01E2 7A			MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
   597 01E3 D3 06			OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
   598 01E5 7B			MOV  A,E	    ; MOVE IN LOWER 8 BITS
   599 01E6 D3 06			OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
   600 01E8 11 00 02		LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
   601 			WRITE_SEC10:
   602 01EB 7E			MOV  A,M	    ; LOAD BYTE INTO A
   603 01EC 23			INX  H		    ; GO TO NEXT BYTE IN BUFFER
   604 01ED D3 06			OUT  HDD_TX_PORT    ; WRITE BYTE
   605 01EF 1D			DCR  E		    ; DECREMENT E
   606 01F0 C2 EB 01		JNZ  WRITE_SEC10    ; RELOOP IF != 0
   607 01F3 15			DCR  D		    ; DECREMENT D AS WELL
   608 01F4 F2 EB 01		JP   WRITE_SEC10    ; RELOOP IF >= 0
   609 01F7 3E 05			MVI  A,END_FRAME    ; SEND ENDFRAME
   610 01F9 D3 06			OUT  HDD_TX_PORT    ; WRITE TO DISK
   611 01FB DB 05			IN   HDD_RX_PORT    ; READ WHAT SHOULD BE A WRITE_OKAY
   612 01FD FE 08			CPI  WRITE_OKAY     ; ? - WHAT WE EXPECT
   613 01FF C2 0E 02		JNZ  WRITE_ERR	    ; N - RETURN
   614 0202 3E 01			MVI  A,ENTER_IDLE   ; TELL IT TO IDLE
   615 0204 D3 06			OUT  HDD_TX_PORT    ; SEND IDLE
   616 0206 DB 05			IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
   617 0208 FE 01			CPI  IDLE	    ; ENSURE IT IS IDLE
   618 020A C2 0E 02		JNZ  WRITE_ERR	    ; RETURN IF NOT
   619 020D AF			XRA  A		    ; ZERO RETURN VALUE
   620 			WRITE_ERR:
   621 020E FB			EI		    ; ENABLE INTERRUPTS
   622 020F C9			RET		    ; RETURN
   623
   624 			;***********************************************************************
   625 			;
   626 			; FUNCTION:  ENTRY
   627 			; PARAMS:    NONE
   628 			; RETURNS:   NONE
   629 			; NOTES:     ATTEMPTS TO LOAD OS. IF FAILS, A BASIC TERMINAL IS STARTED
   630 			; PROC TIME: BEST CASE: 30883 CYCLES
   631 			;
   632 			;***********************************************************************
   633
   634 			ENTRY:
   635 0210 31 80 06		LXI  SP,SYS_STACK      ; LOAD STACK POINTER
   636 0213 FB			EI
   637 0214 3E 00			MVI  A,000H
   638 0216 32 75 08		STA  VIDEO_MEMORY_BASE+500
   639 0219 76			HLT
   640 021A 3E 02			MVI  A,TEXT_MODE       ; SET DISPLAY TO TEXT MODE
   641 021C CD 40 01		CALL SET_VIDEO_MODE
   642 021F 3E 01			MVI  A,INTERRUPT_MODE
   643 0221 CD 77 00		CALL SET_INPUT_MODE    ; SET INPUT TO INTERRUPT MODE
   644 0224 FB			EI		       ; ENABLE INTERRUPTS FOR INPUT
   645 0225 CD 45 01		CALL HARDWARE_TEST     ; TEST HARDWARE
   646
   647 0228 21 81 02		LXI  H,INIT_DATA
   648 022B CD 34 01		CALL PRINT
   649 022E CD 34 01		CALL PRINT	       ; DISPLAY STEP ONE, INITIALIZING REGISTERS
   650 0231 21 81 56		LXI  H,OS_LOADER_BASE
   651 0234 11 00 00		LXI  D,0000H
   652 0237 CD 46 01		CALL READ_SECTOR       ; LOAD 512 BYTE OS LOADER
   653 023A 11 01 00		LXI  D,0001H	       ; LOAD SECTOR 1 ADDR INTO DE
   654 023D 21 80 04		LXI  H,INIT_DATA+511   ; FUCKIN DATA
   655 0240 3E 41			MVI  A,041H
   656 0242 77			MOV  M,A
   657 0243 21 81 02		LXI  H,INIT_DATA
   658 0246 CD B4 01		CALL WRITE_SECTOR      ; TEST THIS BITCH
   659 0249 21 CA 02		LXI  H,PERIOD
   660 024C CD 34 01		CALL PRINT	       ; DISPLAY STEP TWO WAS SUCCESSFUL
   661 024F 21 81 56		LXI  H,OS_LOADER_BASE
   662 0252 11 FE 01		LXI  D,01FEH	       ; MOVE TO LAST TWO BYTES LOADED
   663 0255 19			DAD  D
   664 0256 7E			MOV  A,M
   665 0257 FE FF			CPI  0FFH	       ; THE LAST TWO BYTES SHOULD BE 0XFF, 0XAA
   666 0259 C2 77 02		JNZ  LOAD_ERROR        ; SO HERE WE TEST FOR THAT, AND IF THEY AREN'T
   667 025C E5			PUSH H		       ; WE GO TO OUR MINIMALIST COMMAND LINE
   668 025D 21 CA 02		LXI  H,PERIOD
   669 0260 CD 34 01		CALL PRINT
   670 0263 E1			POP  H
   671 0264 23			INX  H
   672 0265 7E			MOV  A,M
   673 0266 FE AA			CPI  0AAH
   674 0268 C2 77 02		JNZ  LOAD_ERROR
   675 026B 21 CA 02		LXI  H,PERIOD
   676 026E CD 34 01		CALL PRINT
   677 0271 CD F7 00		CALL RESET_CURSOR
   678 0274 C3 81 56		JMP  OS_LOADER_BASE
   679
   680 			LOAD_ERROR:
   681 0277 21 CD 02		LXI  H,LOAD_ERROR_MSG
   682 027A CD 34 01		CALL PRINT
   683 027D 76			HLT
   684 027E C3 81 58		JMP  BIOS_EXTENTION
   685
   686 			INIT_DATA:
   687 0281			DB  0AH, 0AH, '                          DANS PC',0
            0A 0A 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            44 41 4E 53 
            20 50 43 00 
            
   688 02A5			DB  0AH,      '                         LOADING OS',0
            0A 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 4C 4F 
            41 44 49 4E 
            47 20 4F 53 
            00 
   689 			PERIOD:
   690 02CA			DB  '. ',0
            2E 20 00 
   691 			LOAD_ERROR_MSG:
   692 02CD			DB  0AH,      '                       ERROR LOADING OS',0
            0A 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            45 52 52 4F 
            52 20 4C 4F 
            41 44 49 4E 
            47 20 4F 53 
            00 
   693
   694      04 00			ORG BIOS_VAR_BASE
   695
   696 			TRIGGER_MODE:
   697 0400			DS 1
   698 			INPUT_MODE:
   699 0401			DS 1
   700 			BUFFER_INDEX:
   701 0402			DS 1
   702 			PROCESSED_INDEX:
   703 0403			DS 1
   704
   705      04 80			ORG INPUT_BUFFER_BASE
   706 			INPUT_BUFFER:
   707
   708      06 80			ORG SYS_STACK_BASE
   709 			SYS_STACK:


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names			Types	Values
-----			-----	------
ENTER_IDLE		EQU	00001h
REQUEST_WRITE		EQU	00002h
REQUEST_READ		EQU	00003h
START_FRAME		EQU	00004h
END_FRAME		EQU	00005h
STATUS			EQU	00006h
ACKNOWLEDGE		EQU	00007h
WRITE_OKAY		EQU	00008h
READ_OKAY		EQU	00009h
WRITE_ERROR		EQU	000F0h
READ_ERROR		EQU	000F1h
NACK_ERROR		EQU	000F2h
PROC_ERROR		EQU	000F3h
IDLE			EQU	00001h
WRITE_PROC		EQU	00002h
READ_PROC		EQU	00004h
WAITING			EQU	00008h
HDD_REFUSE_IDLE		EQU	000E0h
BIOS_BASE		EQU	00000h
BIOS_SIZE		EQU	00400h
BIOS_VAR_BASE		EQU	00400h
BIOS_VAR_SIZE		EQU	00080h
INPUT_BUFFER_BASE	EQU	00480h
INPUT_BUFFER_SIZE	EQU	00100h
SYS_STACK_SIZE		EQU	00100h
SYS_STACK_BASE		EQU	00680h
VIDEO_MEMORY_BASE	EQU	00681h
VIDEO_MEMORY_SIZE	EQU	05000h
OS_LOADER_BASE		EQU	05681h
OS_LOADER_SIZE		EQU	00200h
BIOS_EXTENTION		EQU	05881h
VIDEO_MODE_PORT		EQU	00001h
TEXT_OPER_PORT		EQU	00002h
TEXT_OUT_PORT		EQU	00003h
KEY_INPUT_PORT		EQU	00004h
HDD_RX_PORT		EQU	00005h
HDD_TX_PORT		EQU	00006h
BANK_PORT		EQU	0000Ah
HDD_IDLE		EQU	00000h
HDD_CMD_ERROR		EQU	000FFh
HDD_NEED_DATA		EQU	00001h
HDD_WRITE_ERROR		EQU	000FEh
HDD_HAVE_DATA		EQU	00002h
HDD_READ_ERROR		EQU	000FDh
HDD_WRITE_DONE		EQU	00003h
HDD_READ_DONE		EQU	00004h
HDD_ENTER_IDLE		EQU	00000h
HDD_START_WRITE		EQU	00001h
HDD_END_WRITE		EQU	000FEh
HDD_START_READ		EQU	00002h
HDD_END_READ		EQU	000FDh
HDD_READ_BYTE		EQU	00003h
HDD_SEND_BYTE		EQU	00004h
TRIGGER_RETURN		EQU	00000h
TRIGGER_KEYDOWN		EQU	00001h
POLLING_MODE		EQU	00000h
INTERRUPT_MODE		EQU	00001h
DELETE_CHAR		EQU	00000h
APPEND_CHAR		EQU	00001h
CARIDGE_RETURN		EQU	00002h
LINE_FEED		EQU	00003h
RESET_SCREEN		EQU	00003h
NEW_LINE		EQU	00002h
HI_RES_MODE		EQU	00000h
LO_RES_MODE		EQU	00001h
TEXT_MODE		EQU	00002h
NULL_INTERRUPT		Label	00073h
SWITCH_BANK		Label	00074h
SET_INPUT_MODE		Label	00077h
ZERO_INPUT_BUFFER	Label	0007Ch
LOOP_ZERO_BUFFER	Label	00086h
KEYBOARD_INT		Label	0008Ch
TOGGLE_STATE		Label	000AEh
EXIT_INTERRUPT		Label	000B6h
GETKEY			Label	000BBh
GET_STATE		Label	000D8h
BACKSPACE		Label	000DBh
NEWLINE			Label	000E9h
RESET_CURSOR		Label	000F7h
DISPCHAR		Label	00106h
GETCHAR			Label	00120h
GETCH			Label	0012Bh
PRINT			Label	00134h
SET_VIDEO_MODE		Label	00140h
HARDWARE_TEST		Label	00145h
READ_SECTOR		Label	00146h
READ_SEC00		Label	00165h
READ_SEC10		Label	00188h
READ_ERR		Label	001B2h
WRITE_SECTOR		Label	001B4h
WRITE_SEC00		Label	001D3h
WRITE_SEC10		Label	001EBh
WRITE_ERR		Label	0020Eh
ENTRY			Label	00210h
LOAD_ERROR		Label	00277h
INIT_DATA		Label	00281h
PERIOD			Label	002CAh
LOAD_ERROR_MSG		Label	002CDh
TRIGGER_MODE		Label	00400h
INPUT_MODE		Label	00401h
BUFFER_INDEX		Label	00402h
PROCESSED_INDEX		Label	00403h
INPUT_BUFFER		Label	00480h
SYS_STACK		Label	00680h

Statistics
----------
"Name"	= 0
"EQU"	= 66
"SET"	= 0
Labels	= 38


