			;***********************************************************************
			;
			; BASIC INPUT/OUTPUT SYSTEM FOR THE DPC BASED AROUND THE INTEL 8080
			; MICRO-PROCESSOR. THIS PROVIDES THE VERY BASIC ROUTINES FOR
			; INTERFACING WITH THE ENVIRONMENT. THIS INCLUDES KEYBOARD INPUT,
			; TEXT AND GRAPHICS DISPLAY, MEMORY BANKING, AND DISK I/O.
			; THERE IS NO SECONDARY PROCESSOR TO HANDLE I/O, AS I AM SHOOTING FOR
			; SIMPLICITY NOT PERFORMANCE.
			;
			;***********************************************************************
			
			;***********************************************************************
			;
			; REGISTERS ARE SAVED BY THE CALLER. THE CALLER ONLY NEEDS TO SAVE
			; REGISTERS THAT IT SEES FIT.
			;
			; ALL REGISTERS MAY BE USED BY THE CALLEE
			;
			; ARGS ARE PASSED THROUGH REGISTERS AND ON TOP OF STACK
			; (MOST 8-BIT VALUES ARE RETURNED THROUGH A AND 16-BIT VALUES IN HL)
			;
			; THE CALLEE IS RESPONSIBLE FOR STACK CLEAN UP
			;
			;***********************************************************************
			
				include "HDD.inc"
			
			;******************************************************************************
			;
			; HDD COMMANDS
			;
			;******************************************************************************
			
            00 01	ENTER_IDLE	EQU	001H	; FORCES CPU INTO IDLE STATE, MAY RESPOND WITH ERROR
            00 02	REQUEST_WRITE	EQU	002H	; REQUESTS TO WRITE, WILL RESPOND WITH ACK IF OKAY
            00 03	REQUEST_READ	EQU	003H	; REQUESTS TO READ, WILL RESPOND WITH ACK IF OKAY
            00 04	START_FRAME	EQU	004H	; INDICATES THE START OF A DATA FRAME
            00 05	END_FRAME	EQU	005H	; INDICATES THE END OF A DATA FRAME
            00 06	STATUS		EQU	006H	; WILL RETURN THE STATUS OF THE DISK.
							; IF THE DISK IS NOT IDLE OR WAITING, AN ERROR WILL RETURN
			
			;******************************************************************************
			;
			; HDD RESPONSES
			;
			;******************************************************************************
			
            00 07	ACKNOWLEDGE	EQU	007H	; RESPONSE TO ACKOWLEDGE A READ/WRITE REQUEST
            00 08	WRITE_OKAY	EQU	008H	; SENT AFTER RECIEVING AN END_FRAME IF THE WRITE WAS SUCCESSFUL
            00 09	READ_OKAY	EQU	009H	; SENT AFTER RECIEVING AN ACK AFTER THE END FRAME OF A READ
            00 F0	WRITE_ERROR	EQU	0F0H	; OCCURS IF AN END_FRAME IS NOT SENT AFTER THE DATA FRAME
            00 F1	READ_ERROR	EQU	0F1H	; OCCURS IF AN END_FRAME IS NOT SENT AFTER THE ADDRESS, OR AN ACK IS NOT SENT AFTER THE DATA OR THE CPU ATTEMPTS TO SEND DATA DURING A READ OPERATION
            00 F2	NACK_ERROR	EQU	0F2H	; OCCURS IF A COMMAND IS NOT RECOGNIZED FROM THE IDLE STATE
            00 F3	PROC_ERROR	EQU	0F3H	; OCCURS IF THE COMMAND IS NOT RECOGNIZED FROM A WAITING STATE
			
			;******************************************************************************
			;
			; HDD STATUSES
			;
			;******************************************************************************
			
            00 01	IDLE		EQU	001H	; DISK IS DOING NOTHING
            00 02	WRITE_PROC	EQU	002H	; DISK IS IN A WRITE PROCESS, EXPECTING DATA FROM CPU
            00 04	READ_PROC	EQU	004H	; DISK IS IN A READ PROCESS, SENDING DATA TO CPU
            00 08	WAITING 	EQU	008H	; DISK IS WAITING FOR A START FRAME OR IDLE COMMAND
			
			;******************************************************************************
			;
			; POTENTIAL HDD ERROR CONDITIONS
			;
			;******************************************************************************
			
            00 E0	HDD_REFUSE_IDLE EQU	0E0H	; OCCURS WHEN THE DISK WILL NOT ENTER AN IDLE STATE; LIKELY THE DISK IS FAULTY
			
			;***********************************************************************
			;
			; ADDRESS MACROS FOR BIOS
			;
			;***********************************************************************
			
            00 00	BIOS_BASE	  EQU 0000H
            04 00	BIOS_SIZE	  EQU 0400H
			
            04 00	BIOS_VAR_BASE	  EQU BIOS_BASE + BIOS_SIZE
            00 80	BIOS_VAR_SIZE	  EQU 0080H
			
            04 80	INPUT_BUFFER_BASE EQU BIOS_VAR_BASE + BIOS_VAR_SIZE
            01 00	INPUT_BUFFER_SIZE EQU 0100H
			
            01 00	SYS_STACK_SIZE	  EQU 00100H
            06 80	SYS_STACK_BASE	  EQU INPUT_BUFFER_BASE+INPUT_BUFFER_SIZE+SYS_STACK_SIZE
			
            06 81	VIDEO_MEMORY_BASE EQU SYS_STACK_BASE+1
            50 00	VIDEO_MEMORY_SIZE EQU 5000H
			
            56 81	OS_LOADER_BASE	  EQU VIDEO_MEMORY_BASE+VIDEO_MEMORY_SIZE
            02 00	OS_LOADER_SIZE	  EQU 0200H
			
            58 81	BIOS_EXTENSION	  EQU OS_LOADER_BASE+OS_LOADER_SIZE
			
			;***********************************************************************
			;
			; PORT MACROS FOR I/O OPERATIONS
			;
			;***********************************************************************
			
            00 01	VIDEO_MODE_PORT EQU 01H
            00 02	TEXT_OPER_PORT	EQU 02H
            00 03	TEXT_OUT_PORT	EQU 03H
			
            00 04	KEY_INPUT_PORT	EQU 04H
			
            00 05	HDD_RX_PORT	EQU 05H
            00 06	HDD_TX_PORT	EQU 06H
			
            00 0A	BANK_PORT	EQU 0AH
			
			;***********************************************************************
			;
			; KEYBOARD MACROS
			;
			;***********************************************************************
			
            00 00	TRIGGER_RETURN	EQU 00H
            00 01	TRIGGER_KEYDOWN EQU 01H
			
            00 00	POLLING_MODE	EQU 00H
            00 01	INTERRUPT_MODE	EQU 01H
			
			;***********************************************************************
			;
			; VIDEO MACROS
			;
			;***********************************************************************
			
            00 00	DELETE_CHAR	EQU 00H
            00 01	APPEND_CHAR	EQU 01H
            00 02	NEW_LINE	EQU 02H
            00 03	RESET_SCREEN	EQU 03H
			
            00 00	HI_RES_MODE	EQU 00H
            00 01	LO_RES_MODE	EQU 01H
            00 02	TEXT_MODE	EQU 02H
			
			;***********************************************************************
			;
			; NOP FILLS BETWEEN INTERRUPT VECTORS
			; IT'S TOO MUCH WORK TO TRY TO WORK AROUND THEM
			; AND MAKES UGLY CODE
			;
			;***********************************************************************
			
			INT_FILL_HALF	MACRO
					NOP
					NOP
					NOP
					NOP
					NOP
					NOP
					ENDM
			
			
			INT_FILL	MACRO
					INT_FILL_HALF
					INT_FILL_HALF
					NOP
					ENDM
			
			
			;***********************************************************************
			;
			; INTERRUPT VECTOR JUMP TABLE
			;
			; BY DEFAULT: 00 - BIOS_START
			;	      08 - KEYBOARD_INTERRUPT
			;	      10 -
			;	      18 -
			;	      20 -
			;	      28 -
			;	      30 -
			;	      38 -
			;
			;***********************************************************************
			
            00 00		ORG BIOS_BASE
			
   140 0000 C3 0F 02		JMP ENTRY
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
     2 0003 00				NOP
     3 0004 00				NOP
     4 0005 00				NOP
     5 0006 00				NOP
     6 0007 00				NOP
     7 0008 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    11 0009 00				NOP
    12 000A 00				NOP
    13 000B 00				NOP
    14 000C 00				NOP
    15 000D 00				NOP
    16 000E 00				NOP
			;\------------- INT_FILL_HALF end
    52 000F 00				NOP
			;\------------- INT_FILL end
			
   144 0010 C3 91 00		JMP KEYBOARD_INT
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    20 0013 00				NOP
    21 0014 00				NOP
    22 0015 00				NOP
    23 0016 00				NOP
    24 0017 00				NOP
    25 0018 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    29 0019 00				NOP
    30 001A 00				NOP
    31 001B 00				NOP
    32 001C 00				NOP
    33 001D 00				NOP
    34 001E 00				NOP
			;\------------- INT_FILL_HALF end
    58 001F 00				NOP
			;\------------- INT_FILL end
			
   148 0020 C3 73 00		JMP NULL_INTERRUPT
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    38 0023 00				NOP
    39 0024 00				NOP
    40 0025 00				NOP
    41 0026 00				NOP
    42 0027 00				NOP
    43 0028 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    47 0029 00				NOP
    48 002A 00				NOP
    49 002B 00				NOP
    50 002C 00				NOP
    51 002D 00				NOP
    52 002E 00				NOP
			;\------------- INT_FILL_HALF end
    64 002F 00				NOP
			;\------------- INT_FILL end
			
   152 0030 C3 73 00		JMP NULL_INTERRUPT
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    56 0033 00				NOP
    57 0034 00				NOP
    58 0035 00				NOP
    59 0036 00				NOP
    60 0037 00				NOP
    61 0038 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    65 0039 00				NOP
    66 003A 00				NOP
    67 003B 00				NOP
    68 003C 00				NOP
    69 003D 00				NOP
    70 003E 00				NOP
			;\------------- INT_FILL_HALF end
    70 003F 00				NOP
			;\------------- INT_FILL end
			
   156 0040 C3 73 00		JMP NULL_INTERRUPT
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    74 0043 00				NOP
    75 0044 00				NOP
    76 0045 00				NOP
    77 0046 00				NOP
    78 0047 00				NOP
    79 0048 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    83 0049 00				NOP
    84 004A 00				NOP
    85 004B 00				NOP
    86 004C 00				NOP
    87 004D 00				NOP
    88 004E 00				NOP
			;\------------- INT_FILL_HALF end
    76 004F 00				NOP
			;\------------- INT_FILL end
			
   160 0050 C3 73 00		JMP NULL_INTERRUPT
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
    92 0053 00				NOP
    93 0054 00				NOP
    94 0055 00				NOP
    95 0056 00				NOP
    96 0057 00				NOP
    97 0058 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
   101 0059 00				NOP
   102 005A 00				NOP
   103 005B 00				NOP
   104 005C 00				NOP
   105 005D 00				NOP
   106 005E 00				NOP
			;\------------- INT_FILL_HALF end
    82 005F 00				NOP
			;\------------- INT_FILL end
			
   164 0060 C3 73 00		JMP NULL_INTERRUPT
			
				INT_FILL
			;/------------- INT_FILL start
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
   110 0063 00				NOP
   111 0064 00				NOP
   112 0065 00				NOP
   113 0066 00				NOP
   114 0067 00				NOP
   115 0068 00				NOP
			;\------------- INT_FILL_HALF end
					INT_FILL_HALF
			;/------------- INT_FILL_HALF start
   119 0069 00				NOP
   120 006A 00				NOP
   121 006B 00				NOP
   122 006C 00				NOP
   123 006D 00				NOP
   124 006E 00				NOP
			;\------------- INT_FILL_HALF end
    88 006F 00				NOP
			;\------------- INT_FILL end
			
   168 0070 C3 73 00		JMP NULL_INTERRUPT
			
			
			NULL_INTERRUPT:
   172 0073 C9			RET
			
			
			;***********************************************************************
			;
			; FUNCTION:  SWITCH_BANK
			; PARAMS:    BANK NUMBER IN A
			; RETURNS:   NONE
			; NOTES:     SWITCHES THE MEMORY BANK. BE PREPARED.
			; PROC TIME: 20 CYCLES
			;
			;***********************************************************************
			
			SWITCH_BANK:
   186 0074 D3 0A		OUT BANK_PORT
   187 0076 C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  SET_VIDE0_MODE
			; PARAMS:    MODE CODE IN A
			; RETURNS:   MODE SENT IN A
			; NOTES:     CHANGES THE DISPLAY MODE
			; PROC TIME: 27 CYCLES
			;
			;***********************************************************************
			
			SET_VIDEO_MODE:
   200 0077 E6 03		ANI 011B
   201 0079 D3 01		OUT VIDEO_MODE_PORT
   202 007B C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  SET_INPUT_MODE
			; PARAMS:    MODE CODE IN A
			; RETURNS:   MODE SENT
			; NOTES:     CHANGES THE INPUT MODE TO EITHER INTERRUPT OR POLLING
			; PROC TIME: 5702 CYCLES
			;
			;***********************************************************************
			
			SET_INPUT_MODE:
   215 007C E6 01		ANI  01H
   216 007E 32 01 04		STA  INPUT_MODE
			
			
			;***********************************************************************
			;
			; FUNCTION:  ZERO_INPUT_BUFFER
			; PARAMS:    NONE
			; RETURNS:   NONE
			; NOTES:     ZEROS THE BUFFER AND COUNTERS
			; PROC TIME: 5682 CYCLES
			;
			;***********************************************************************
			
			ZERO_INPUT_BUFFER:
   230 0081 AF			XRA  A
   231 0082 32 02 04		STA  BUFFER_INDEX
   232 0085 32 03 04		STA  PROCESSED_INDEX
   233 0088 21 80 04		LXI  H,INPUT_BUFFER
			LOOP_ZERO_BUFFER:
   235 008B 77			MOV  M,A
   236 008C 2C			INR  L
   237 008D C2 8B 00		JNZ  LOOP_ZERO_BUFFER
   238 0090 C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  KEYBOARD_INT
			; PARAMS:    NONE
			; RETURNS:   KEY PRESSED
			; NOTES:     TRIGGERED WHENEVER A KEY IS PRESSED
			;	     IF IN INTERRUPT MODE, ADDS KEY TO THE BUFFER
			;	     IF IN POLLING MODE, THE STATE OF THE KEY IS TOGGLED
			; PROC TIME: 158-216 CYCLES
			;
			;***********************************************************************
			
			KEYBOARD_INT:
   253 0091 F5			PUSH PSW	     ; ENTER INTERRUPT
   254 0092 C5			PUSH B
   255 0093 D5			PUSH D
   256 0094 E5			PUSH H
   257 0095 21 80 04		LXI  H,INPUT_BUFFER  ; LOAD H WITH BUFFER ADDRESS
   258 0098 3A 01 04		LDA  INPUT_MODE      ; TEST IF WE'RE IN INTERRUPT MODE
   259 009B B7			ORA  A
   260 009C CA B3 00		JZ   TOGGLE_STATE    ; IF WE'RE NOT, THEN GO TO POLLING MODE
   261 009F DB 04		IN   KEY_INPUT_PORT  ; IF WE ARE, GET KEY PRESSED
   262 00A1 FE 80		CPI  10000000B	     ; IF KEY PRESSED > 127 THAN IT'S SIGNALING BEING RELEASED
   263 00A3 F2 BB 00		JP   EXIT_INTERRUPT  ; WE DON'T RECORD RELEASES IN INTERRUPT MODE SO EXIT
   264 00A6 47			MOV  B,A	     ; IF RECORDING, SAVE CHAR IN B
   265 00A7 3A 02 04		LDA  BUFFER_INDEX    ; LOAD A WITH INDEX
   266 00AA 6F			MOV  L,A	     ; BECAUSE THE BUFFER IS AT 0300H, WE JUST MOVE A INTO L
   267 00AB 3C			INR  A		     ; INCREMENT TO NEXT MEMORY LOCATION
   268 00AC 32 02 04		STA  BUFFER_INDEX    ; STORE MEMORY LOCATION FOR NEXT CALL
   269 00AF 70			MOV  M,B	     ; STORE CHAR
   270 00B0 C3 BB 00		JMP  EXIT_INTERRUPT
			
			TOGGLE_STATE:
   273 00B3 DB 04		IN   KEY_INPUT_PORT  ; GET KEY PRESSED
   274 00B5 E6 7F		ANI  01111111B	     ; IGNORE STATE, AS TOGGLING HANDLES THIS
   275 00B7 6F			MOV  L,A
   276 00B8 7E			MOV  A,M
   277 00B9 2F			CMA		     ; TOGGLE KEY STATE
   278 00BA 77			MOV  M,A
			
			;***********************************************************************
			;
			; FUNCTION:  EXIT_INTERRUPT
			; PARAMS:    NONE
			; RETURNS:   NONE
			; NOTES:     RESTORES THE STATE OF ALL REGISTERS FROM ENTER_INTERRUPT
			; PROC TIME: 50 CYCLES
			;
			;***********************************************************************
			EXIT_INTERRUPT:
   290 00BB E1			POP  H
   291 00BC D1			POP  D
   292 00BD C1			POP  B
   293 00BE F1			POP  PSW
   294 00BF C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  GETKEY
			; PARAMS:    IF IN POLLING MODE, THEN KEY IN A
			;	     IF IN INTERRUPT MODE, THEN NONE
			; RETURNS:   IF IN POLLING MODE, STATE OF KEY IN A
			;	     OTHERWISE NEXT KEY IN BUFFER IN A OR -1 IF NO KEYS PRESSED
			; NOTES:
			; PROC TIME: 62/93 CYCLES
			;
			;***********************************************************************
			
			GETKEY:
   309 00C0 21 80 04		LXI H,INPUT_BUFFER    ; LOAD HL WITH BUFFER ADDRESS
   310 00C3 47			MOV B,A 	      ; STORE CHAR IN B INCASE WE'RE IN POLLING MODE
   311 00C4 3A 01 04		LDA INPUT_MODE	      ; CHECK IF WE'RE IN INTERRUPT MODE
   312 00C7 B7			ORA A
   313 00C8 CA DD 00		JZ  GET_STATE	      ; IF NOT GO TO GET THE KEY STATE
   314 00CB 3A 03 04		LDA PROCESSED_INDEX   ; LOAD CURRENT INDEX OF PROCESSED KEYS
   315 00CE 6F			MOV L,A 	      ; STORE IN LOWER ADDRESS
   316 00CF 3A 02 04		LDA BUFFER_INDEX      ; LOAD INDEX OF UNPROCESSED KEYS
   317 00D2 BD			CMP L
   318 00D3 3E FF		MVI A,0FFH
   319 00D5 C8			RZ		      ; IF WE'RE AT THE SAME INDEX, NO KEYS HAVE BEEN PRESSED
   320 00D6 7D			MOV A,L
   321 00D7 3C			INR A
   322 00D8 32 03 04		STA PROCESSED_INDEX   ; STORE THE NEXT INDEX
   323 00DB 7E			MOV A,M 	      ; LOAD A WITH KEY PRESSED
   324 00DC C9			RET		      ; GTFO
			
			GET_STATE:
   327 00DD 68			MOV L,B 	      ; MOVE INDEX OF KEY TO LOWER ADDRESS
   328 00DE 7E			MOV A,M 	      ; GET KEY STATE
   329 00DF C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  BACKSPACE
			; PARAMS:    NONE
			; RETURNS:   -1 IF NOT IN TEXT MODE
			; NOTES:     DELETES THE PREVIOUS CHARACTER
			; PROC TIME: 28/59 CYCLES
			;
			;***********************************************************************
			
			BACKSPACE:
   342 00E0 DB 01		IN  VIDEO_MODE_PORT
   343 00E2 FE 02		CPI TEXT_MODE
   344 00E4 3E FF		MVI A,0FFH
   345 00E6 C0			RNZ
   346 00E7 3E 00		MVI A,DELETE_CHAR
   347 00E9 D3 02		OUT TEXT_OPER_PORT
   348 00EB D3 03		OUT TEXT_OUT_PORT
   349 00ED C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  NEWLINE
			; PARAMS:    NONE
			; RETURNS:   -1 IF NOT IN TEXT MODE
			; NOTES:     GOES TO NEXT LINE IN DISPLAY
			; PROC TIME: 28/59 CYCLES
			;
			;***********************************************************************
			
			NEWLINE:
   362 00EE DB 01		IN  VIDEO_MODE_PORT
   363 00F0 FE 02		CPI TEXT_MODE
   364 00F2 3E FF		MVI A,0FFH
   365 00F4 C0			RNZ
   366 00F5 3E 02		MVI A,NEW_LINE
   367 00F7 D3 02		OUT TEXT_OPER_PORT
   368 00F9 D3 03		OUT TEXT_OUT_PORT
   369 00FB C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  RESET_CURSOR
			; PARAMS:    NONE
			; RETURNS:   -1 IN A IF NOT IN TEXT MODE, ELSE NONE
			; NOTES:     SETS CURSOR TO 0
			; PROC TIME: 28/63 CYCLES
			;
			;***********************************************************************
			
			RESET_CURSOR:
   382 00FC DB 01		IN  VIDEO_MODE_PORT
   383 00FE FE 02		CPI TEXT_MODE
   384 0100 3E FF		MVI A,0FFH
   385 0102 C0			RNZ
   386 0103 3E 03		MVI A,RESET_SCREEN
   387 0105 D3 02		OUT TEXT_OPER_PORT
   388 0107 AF			XRA A
   389 0108 D3 03		OUT TEXT_OUT_PORT
   390 010A C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  DISPCHAR
			; PARAMS:    CHAR TO DISPLAY IN A
			; RETURNS:   CHAR DISPLAYED OR -1 IF NOT IN TEXT MODE
			; NOTES:     DISPLAYS CHARACTER TO SCREEN AT CURSOR POSITION THEN
			;	     INCREMENTS CURSOR
			; PROC TIME: 45-110 CYCLES
			;
			;***********************************************************************
			
			DISPCHAR:
   404 010B FE 08		CPI 08H
   405 010D CA E0 00		JZ  BACKSPACE
   406 0110 FE 0A		CPI 0AH
   407 0112 CA EE 00		JZ  NEWLINE
   408 0115 47			MOV B,A
   409 0116 DB 01		IN  VIDEO_MODE_PORT
   410 0118 FE 02		CPI TEXT_MODE
   411 011A 3E FF		MVI A,0FFH
   412 011C C0			RNZ
   413 011D 3E 01		MVI A,APPEND_CHAR
   414 011F D3 02		OUT TEXT_OPER_PORT
   415 0121 78			MOV A,B
   416 0122 D3 03		OUT TEXT_OUT_PORT
   417 0124 C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  PRINT
			; PARAMS:    BASE OF NULL-TERMINATED STRING IN HL
			; RETURNS:   0 IN A IF SUCCESSFUL
			; NOTES:
			; PROC TIME: 127*(STRLEN+1) + 69
			;
			;***********************************************************************
			
			PRINT:
   430 0125 7E			MOV  A,M
   431 0126 23			INX  H
   432 0127 CD 0B 01		CALL DISPCHAR
   433 012A B7			ORA  A
   434 012B C2 25 01		JNZ  PRINT
   435 012E C3 E0 00		JMP  BACKSPACE
				
			;***********************************************************************
			;
			; FUNCTION:  GETCHAR
			; PARAMS:    NONE
			; RETURNS:   CHARACTER CODE OF INPUT KEY
			; NOTES:     WAITS FOR A KEY TO GET PRESSED AND DISPLAYS IT TO SCREEN
			; PROC TIME:
			;
			;***********************************************************************	
			
			GETCHAR:
   448 0131 CD C0 00		CALL GETKEY
   449 0134 FE FF		CPI  0FFH
   450 0136 CA 31 01		JZ   GETCHAR
   451 0139 C3 0B 01		JMP  DISPCHAR
			
			;***********************************************************************
			;
			; FUNCTION:  GETCH
			; PARAMS:    NONE
			; RETURNS:   CHARACTER CODE OF INPUT KEY
			; NOTES:     RETURNS KEY PRESSED WITHOUT ECHO
			; PROC TIME:
			;
			;***********************************************************************
			
			GETCH:
   464 013C CD C0 00		CALL GETKEY
   465 013F FE FF		CPI  0FFH
   466 0141 CA 3C 01		JZ   GETCH
   467 0144 C9			RET
			
			;***********************************************************************
			;
			; FUNCTION:  READ_SECTOR
			; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
			; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
			; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
			;				 C C C C C C C H  |  H H S S S S S S
			;	     THIS IS THE CORE READ OPERATION, WHICH SHOULD ONLY
			;	     BE PERFORMED UNDER THE DISGRESSION OF THE OS.
			; PROC TIME: BEST CASE: 30883 CYCLES
			;
			;***********************************************************************
			
			READ_SECTOR:
   483 0145 F3			DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
   484 0146 3E 06		MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
   485 0148 D3 06		OUT  HDD_TX_PORT
   486 014A DB 05		IN   HDD_RX_PORT
   487 014C FE 01		CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
   488 014E CA 64 01		JZ   READ_SEC00     ; IT IS IDLE, SO PERFORM READ
   489 0151 3E 01		MVI  A,ENTER_IDLE   ; FORCE TO IDLE
   490 0153 D3 06		OUT  HDD_TX_PORT
   491 0155 3E 06		MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
   492 0157 D3 06		OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
   493 0159 DB 05		IN   HDD_RX_PORT    ; GET STATUS
   494 015B FE 01		CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
   495 015D CA 64 01		JZ   READ_SEC00     ; CONTINUE
   496 0160 FB			EI		    ; RE-ENABLE INTERRUPTS
   497 0161 3E E0		MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
   498 0163 C9			RET			; RETURN
			READ_SEC00:
   500 0164 3E 03		MVI  A,REQUEST_READ ; REQUEST READ OPERATION
   501 0166 D3 06		OUT  HDD_TX_PORT
   502 0168 DB 05		IN   HDD_RX_PORT    ; GET RESPONSE
   503 016A FE 07		CPI  ACKNOWLEDGE    ; ? - ACK
   504 016C C2 B1 01		JNZ  READ_ERR	    ; N - RETURN
   505 016F 3E 04		MVI  A,START_FRAME  ; SEND A START FRAME
   506 0171 D3 06		OUT  HDD_TX_PORT
   507 0173 7A			MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
   508 0174 D3 06		OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
   509 0176 7B			MOV  A,E	    ; MOVE IN LOWER 8 BITS
   510 0177 D3 06		OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
   511 0179 3E 05		MVI  A,END_FRAME    ; END FRAME
   512 017B D3 06		OUT  HDD_TX_PORT    ; SEND
   513 017D DB 05		IN   HDD_RX_PORT    ;
   514 017F FE 04		CPI  START_FRAME    ; ? - START FRAME
   515 0181 C2 B1 01		JNZ  READ_ERR	    ; N - RETURN
   516 0184 11 00 02		LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
			READ_SEC10:
   518 0187 DB 05		IN   HDD_RX_PORT    ; READ A BYTE
   519 0189 77			MOV  M,A	    ; STORE BYTE IN BUFFER
   520 018A 23			INX  H		    ; INCREMENT BUFFER PTR
   521 018B 1D			DCR  E		    ; DECREMENT E
   522 018C C2 87 01		JNZ  READ_SEC10     ; RELOOP IF != 0
   523 018F 15			DCR  D		    ; DECREMENT D AS WELL
   524 0190 C2 87 01		JNZ  READ_SEC10     ; RELOOP IF != 0
   525 0193 DB 05		IN   HDD_RX_PORT    ; READ WHAT SHOULD BE AN END_FRAME
   526 0195 FE 05		CPI  END_FRAME	    ; ? - WHAT WE EXPECT
   527 0197 C2 B1 01		JNZ  READ_ERR	    ; N - RETURN
   528 019A 3E 07		MVI  A,ACKNOWLEDGE  ; LOAD ACK
   529 019C D3 06		OUT  HDD_TX_PORT    ; SEND ACK
   530 019E DB 05		IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
   531 01A0 FE 09		CPI  READ_OKAY	    ; ENSURE THE READ IS OKAY
   532 01A2 C2 B1 01		JNZ  READ_ERR	    ; RETURN IF NOT
   533 01A5 3E 01		MVI  A,ENTER_IDLE   ;
   534 01A7 D3 06		OUT  HDD_TX_PORT    ; SEND COMMAND TO IDLE
   535 01A9 DB 05		IN   HDD_RX_PORT    ; SHOULD RECIEVE IDLE
   536 01AB FE 01		CPI  IDLE	    ; ? - WHAT WE EXPECT
   537 01AD C2 B1 01		JNZ  READ_ERR	    ; N - RETURN EARLY
   538 01B0 AF			XRA  A		    ; ZERO RETURN VALUE
			READ_ERR:
   540 01B1 FB			EI		    ; ENABLE INTERRUPTS
   541 01B2 C9			RET		    ; RETURN
			
			;***********************************************************************
			;
			; FUNCTION:  WRITE_SECTOR
			; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
			; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
			; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
			;				 C C C C C C C H  |  H H S S S S S S
			;	     THIS IS THE CORE WRITE OPERATION, WHICH SHOULD ONLY
			;	     BE PERFORMED UNDER THE DISGRESSION OF THE OS.
			; PROC TIME: BEST CASE: 30883 CYCLES
			;
			;***********************************************************************
			
			WRITE_SECTOR:
   557 01B3 F3			DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
   558 01B4 3E 06		MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
   559 01B6 D3 06		OUT  HDD_TX_PORT
   560 01B8 DB 05		IN   HDD_RX_PORT
   561 01BA FE 01		CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
   562 01BC CA D2 01		JZ   WRITE_SEC00    ; IT IS IDLE, SO PERFORM WRITE
   563 01BF 3E 01		MVI  A,ENTER_IDLE   ; FORCE TO IDLE
   564 01C1 D3 06		OUT  HDD_TX_PORT
   565 01C3 3E 06		MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
   566 01C5 D3 06		OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
   567 01C7 DB 05		IN   HDD_RX_PORT    ; GET STATUS
   568 01C9 FE 01		CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
   569 01CB CA D2 01		JZ   WRITE_SEC00    ; CONTINUE
   570 01CE FB			EI		    ; RE-ENABLE INTERRUPTS
   571 01CF 3E E0		MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
   572 01D1 C9			RET			; RETURN
			WRITE_SEC00:
   574 01D2 3E 02		MVI  A,REQUEST_WRITE; REQUEST READ OPERATION
   575 01D4 D3 06		OUT  HDD_TX_PORT
   576 01D6 DB 05		IN   HDD_RX_PORT    ; GET RESPONSE
   577 01D8 FE 07		CPI  ACKNOWLEDGE    ; ? - ACK
   578 01DA C2 0D 02		JNZ  WRITE_ERR	    ; N - RETURN
   579 01DD 3E 04		MVI  A,START_FRAME  ; SEND A START FRAME
   580 01DF D3 06		OUT  HDD_TX_PORT
   581 01E1 7A			MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
   582 01E2 D3 06		OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
   583 01E4 7B			MOV  A,E	    ; MOVE IN LOWER 8 BITS
   584 01E5 D3 06		OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
   585 01E7 11 00 02		LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
			WRITE_SEC10:
   587 01EA 7E			MOV  A,M	    ; LOAD BYTE INTO A
   588 01EB 23			INX  H		    ; GO TO NEXT BYTE IN BUFFER
   589 01EC D3 06		OUT  HDD_TX_PORT    ; WRITE BYTE
   590 01EE 1D			DCR  E		    ; DECREMENT E
   591 01EF C2 EA 01		JNZ  WRITE_SEC10    ; RELOOP IF != 0
   592 01F2 15			DCR  D		    ; DECREMENT D AS WELL
   593 01F3 C2 EA 01		JNZ  WRITE_SEC10    ; RELOOP IF != 0
   594 01F6 3E 05		MVI  A,END_FRAME    ; SEND ENDFRAME
   595 01F8 D3 06		OUT  HDD_TX_PORT    ; WRITE TO DISK
   596 01FA DB 05		IN   HDD_RX_PORT    ; READ WHAT SHOULD BE A WRITE_OKAY
   597 01FC FE 08		CPI  WRITE_OKAY     ; ? - WHAT WE EXPECT
   598 01FE C2 0D 02		JNZ  WRITE_ERR	    ; N - RETURN
   599 0201 3E 01		MVI  A,ENTER_IDLE   ; TELL IT TO IDLE
   600 0203 D3 06		OUT  HDD_TX_PORT    ; SEND IDLE
   601 0205 DB 05		IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
   602 0207 FE 01		CPI  IDLE	    ; ENSURE IT IS IDLE
   603 0209 C2 0D 02		JNZ  WRITE_ERR	    ; RETURN IF NOT
   604 020C AF			XRA  A		    ; ZERO RETURN VALUE
			WRITE_ERR:
   606 020D FB			EI		    ; ENABLE INTERRUPTS
   607 020E C9			RET		    ; RETURN
			
			;***********************************************************************
			;
			; FUNCTION:  ENTRY
			; PARAMS:    NONE
			; RETURNS:   NONE
			; NOTES:     ATTEMPTS TO LOAD OS. IF FAILS, A BASIC TERMINAL IS STARTED
			; PROC TIME: BEST CASE: 30883 CYCLES
			;
			;***********************************************************************
			
			;***********************************************************************
			;
			; FUNCTION:  HARDWARE_TEST
			; PARAMS:    NONE
			; RETURNS:   0 IF SUCCESSFUL, OTHERWISE ERROR CODE IN A
			; NOTES:     TESTS EVERYTHING EVER.
			; PROC TIME:
			;
			;***********************************************************************
			
			ENTRY:
   630 020F 31 80 06		LXI  SP,SYS_STACK      ; LOAD STACK POINTER
   631 0212 3E 00		MVI  A,000H
   632 0214 32 75 08		STA  VIDEO_MEMORY_BASE+500
   633 0217 3E 02		MVI  A,TEXT_MODE       ; SET DISPLAY TO TEXT MODE
   634 0219 CD 77 00		CALL SET_VIDEO_MODE
   635 021C 3E 01		MVI  A,INTERRUPT_MODE
   636 021E CD 7C 00		CALL SET_INPUT_MODE    ; SET INPUT TO INTERRUPT MODE
   637 0221 FB			EI		       ; ENABLE INTERRUPTS FOR INPUT
   638 0222 21 7E 02		LXI  H,INIT_DATA
   639 0225 CD 25 01		CALL PRINT
   640 0228 CD 25 01		CALL PRINT
   641 022B CD 25 01		CALL PRINT	       ; DISPLAY STEP ONE, INITIALIZING REGISTERS
   642 022E 21 81 56		LXI  H,OS_LOADER_BASE
   643 0231 11 00 00		LXI  D,0000H
   644 0234 CD 45 01		CALL READ_SECTOR       ; LOAD 512 BYTE OS LOADER
   645 0237 11 01 00		LXI  D,0001H	       ; LOAD SECTOR 1 ADDR INTO DE
   646 023A 21 7D 04		LXI  H,INIT_DATA+511   ; FUCKIN DATA
   647 023D 3E 41		MVI  A,041H
   648 023F 77			MOV  M,A
   649 0240 21 7E 02		LXI  H,INIT_DATA
   650 0243 CD B3 01		CALL WRITE_SECTOR      ; TEST THIS BITCH
   651 0246 21 C7 02		LXI  H,PERIOD
   652 0249 CD 25 01		CALL PRINT	       ; DISPLAY STEP TWO WAS SUCCESSFUL
   653 024C 21 81 56		LXI  H,OS_LOADER_BASE
   654 024F 11 FE 01		LXI  D,01FEH	       ; MOVE TO LAST TWO BYTES LOADED
   655 0252 19			DAD  D
   656 0253 7E			MOV  A,M
   657 0254 FE FF		CPI  0FFH	       ; THE LAST TWO BYTES SHOULD BE 0XFF, 0XAA
   658 0256 C2 74 02		JNZ  LOAD_ERROR        ; SO HERE WE TEST FOR THAT, AND IF THEY AREN'T
   659 0259 E5			PUSH H		       ; WE GO TO OUR MINIMALIST COMMAND LINE
   660 025A 21 C7 02		LXI  H,PERIOD
   661 025D CD 25 01		CALL PRINT
   662 0260 E1			POP  H
   663 0261 23			INX  H
   664 0262 7E			MOV  A,M
   665 0263 FE AA		CPI  0AAH
   666 0265 C2 74 02		JNZ  LOAD_ERROR
   667 0268 21 C7 02		LXI  H,PERIOD
   668 026B CD 25 01		CALL PRINT
   669 026E CD FC 00		CALL RESET_CURSOR
   670 0271 C3 81 56		JMP  OS_LOADER_BASE
			
			LOAD_ERROR:
   673 0274 21 CA 02		LXI  H,LOAD_ERROR_MSG
   674 0277 CD 25 01		CALL PRINT
   675 027A 76			HLT
   676 027B C3 81 58		JMP  BIOS_EXTENSION
			
			INIT_DATA:
   679 027E			DB  0AH, 0AH, '                          DANS PC',0
            0A 0A 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            44 41 4E 53 
            20 50 43 00 
            
   680 02A2			DB  0AH,      '                         LOADING OS',0
            0A 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 4C 4F 
            41 44 49 4E 
            47 20 4F 53 
            00 
			PERIOD:
   682 02C7			DB  '. ',0
            2E 20 00 
			LOAD_ERROR_MSG:
   684 02CA			DB  0AH,      '                       ERROR LOADING OS',0
            0A 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            45 52 52 4F 
            52 20 4C 4F 
            41 44 49 4E 
            47 20 4F 53 
            00 
			
            04 00		ORG BIOS_VAR_BASE
			
			TRIGGER_MODE:
   689 0400			DS 1
			INPUT_MODE:
   691 0401			DS 1
			BUFFER_INDEX:
   693 0402			DS 1
			PROCESSED_INDEX:
   695 0403			DS 1
			
            04 80		ORG INPUT_BUFFER_BASE
			INPUT_BUFFER:
			
            06 80		ORG SYS_STACK_BASE
			SYS_STACK:


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names			Types	Values
-----			-----	------
ENTER_IDLE		EQU	00001h
REQUEST_WRITE		EQU	00002h
REQUEST_READ		EQU	00003h
START_FRAME		EQU	00004h
END_FRAME		EQU	00005h
STATUS			EQU	00006h
ACKNOWLEDGE		EQU	00007h
WRITE_OKAY		EQU	00008h
READ_OKAY		EQU	00009h
WRITE_ERROR		EQU	000F0h
READ_ERROR		EQU	000F1h
NACK_ERROR		EQU	000F2h
PROC_ERROR		EQU	000F3h
IDLE			EQU	00001h
WRITE_PROC		EQU	00002h
READ_PROC		EQU	00004h
WAITING			EQU	00008h
HDD_REFUSE_IDLE		EQU	000E0h
BIOS_BASE		EQU	00000h
BIOS_SIZE		EQU	00400h
BIOS_VAR_BASE		EQU	00400h
BIOS_VAR_SIZE		EQU	00080h
INPUT_BUFFER_BASE	EQU	00480h
INPUT_BUFFER_SIZE	EQU	00100h
SYS_STACK_SIZE		EQU	00100h
SYS_STACK_BASE		EQU	00680h
VIDEO_MEMORY_BASE	EQU	00681h
VIDEO_MEMORY_SIZE	EQU	05000h
OS_LOADER_BASE		EQU	05681h
OS_LOADER_SIZE		EQU	00200h
BIOS_EXTENSION		EQU	05881h
VIDEO_MODE_PORT		EQU	00001h
TEXT_OPER_PORT		EQU	00002h
TEXT_OUT_PORT		EQU	00003h
KEY_INPUT_PORT		EQU	00004h
HDD_RX_PORT		EQU	00005h
HDD_TX_PORT		EQU	00006h
BANK_PORT		EQU	0000Ah
TRIGGER_RETURN		EQU	00000h
TRIGGER_KEYDOWN		EQU	00001h
POLLING_MODE		EQU	00000h
INTERRUPT_MODE		EQU	00001h
DELETE_CHAR		EQU	00000h
APPEND_CHAR		EQU	00001h
NEW_LINE		EQU	00002h
RESET_SCREEN		EQU	00003h
HI_RES_MODE		EQU	00000h
LO_RES_MODE		EQU	00001h
TEXT_MODE		EQU	00002h
NULL_INTERRUPT		Label	00073h
SWITCH_BANK		Label	00074h
SET_VIDEO_MODE		Label	00077h
SET_INPUT_MODE		Label	0007Ch
ZERO_INPUT_BUFFER	Label	00081h
LOOP_ZERO_BUFFER	Label	0008Bh
KEYBOARD_INT		Label	00091h
TOGGLE_STATE		Label	000B3h
EXIT_INTERRUPT		Label	000BBh
GETKEY			Label	000C0h
GET_STATE		Label	000DDh
BACKSPACE		Label	000E0h
NEWLINE			Label	000EEh
RESET_CURSOR		Label	000FCh
DISPCHAR		Label	0010Bh
PRINT			Label	00125h
GETCHAR			Label	00131h
GETCH			Label	0013Ch
READ_SECTOR		Label	00145h
READ_SEC00		Label	00164h
READ_SEC10		Label	00187h
READ_ERR		Label	001B1h
WRITE_SECTOR		Label	001B3h
WRITE_SEC00		Label	001D2h
WRITE_SEC10		Label	001EAh
WRITE_ERR		Label	0020Dh
ENTRY			Label	0020Fh
LOAD_ERROR		Label	00274h
INIT_DATA		Label	0027Eh
PERIOD			Label	002C7h
LOAD_ERROR_MSG		Label	002CAh
TRIGGER_MODE		Label	00400h
INPUT_MODE		Label	00401h
BUFFER_INDEX		Label	00402h
PROCESSED_INDEX		Label	00403h
INPUT_BUFFER		Label	00480h
SYS_STACK		Label	00680h

Statistics
----------
"Name"	= 0
"EQU"	= 49
"SET"	= 0
Labels	= 37


