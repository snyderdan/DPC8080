     1 			;***********************************************************************
     2 			;
     3 			; BASIC INPUT/OUTPUT SYSTEM FOR THE DPC BASED AROUND THE INTEL 8080
     4 			; MICRO-PROCESSOR. THIS PROVIDES THE VERY BASIC ROUTINES FOR
     5 			; INTERFACING WITH THE ENVIRONMENT. THIS INCLUDES KEYBOARD INPUT,
     6 			; TEXT AND GRAPHICS DISPLAY, MEMORY BANKING, AND DISK I/O.
     7 			; THERE IS NO SECONDARY PROCESSOR TO HANDLE I/O, AS I AM SHOOTING FOR
     8 			; SIMPLICITY NOT PERFORMANCE.
     9 			;
    10 			;***********************************************************************
    11
    12 			;***********************************************************************
    13 			;
    14 			; REGISTERS ARE SAVED BY THE CALLER. THE CALLER ONLY NEEDS TO SAVE
    15 			; REGISTERS THAT IT SEES FIT.
    16 			;
    17 			; ALL REGISTERS MAY BE USED BY THE CALLEE
    18 			;
    19 			; ARGS ARE PASSED THROUGH REGISTERS AND ON TOP OF STACK
    20 			; (MOST 8-BIT VALUES ARE RETURNED THROUGH A AND 16-BIT VALUES IN HL)
    21 			;
    22 			; THE CALLEE IS RESPONSIBLE FOR STACK CLEAN UP
    23 			;
    24 			;***********************************************************************
    25
    26     			include "HDD.INC"
     1
     2 			;******************************************************************************
     3 			;
     4 			; HDD COMMANDS
     5 			;
     6 			;******************************************************************************
     7
     8      00 01		ENTER_IDLE	EQU	001H	; FORCES CPU INTO IDLE STATE, MAY RESPOND WITH ERROR
     9      00 02		REQUEST_WRITE	EQU	002H	; REQUESTS TO WRITE, WILL RESPOND WITH ACK IF OKAY
    10      00 03		REQUEST_READ	EQU	003H	; REQUESTS TO READ, WILL RESPOND WITH ACK IF OKAY
    11      00 04		START_FRAME	EQU	004H	; INDICATES THE START OF A DATA FRAME
    12      00 05		END_FRAME	EQU	005H	; INDICATES THE END OF A DATA FRAME
    13      00 06		STATUS		EQU	006H	; WILL RETURN THE STATUS OF THE DISK.
    14 							; IF THE DISK IS NOT IDLE OR WAITING, AN ERROR WILL RETURN
    15
    16 			;******************************************************************************
    17 			;
    18 			; HDD RESPONSES
    19 			;
    20 			;******************************************************************************
    21
    22      00 07		ACKNOWLEDGE	EQU	007H	; RESPONSE TO ACKOWLEDGE A READ/WRITE REQUEST
    23      00 08		WRITE_OKAY	EQU	008H	; SENT AFTER RECIEVING AN END_FRAME IF THE WRITE WAS SUCCESSFUL
    24      00 09		READ_OKAY	EQU	009H	; SENT AFTER RECIEVING AN ACK AFTER THE END FRAME OF A READ
    25      00 F0		WRITE_ERROR	EQU	0F0H	; OCCURS IF AN END_FRAME IS NOT SENT AFTER THE DATA FRAME
    26      00 F1		READ_ERROR	EQU	0F1H	; OCCURS IF AN END_FRAME IS NOT SENT AFTER THE ADDRESS, OR AN ACK IS NOT SENT AFTER THE DATA OR THE CPU ATTEMPTS TO SEND DATA DURING A READ OPERATION
    27      00 F2		NACK_ERROR	EQU	0F2H	; OCCURS IF A COMMAND IS NOT RECOGNIZED FROM THE IDLE STATE
    28      00 F3		PROC_ERROR	EQU	0F3H	; OCCURS IF THE COMMAND IS NOT RECOGNIZED FROM A WAITING STATE
    29
    30 			;******************************************************************************
    31 			;
    32 			; HDD STATUSES
    33 			;
    34 			;******************************************************************************
    35
    36      00 01		IDLE		EQU	001H	; DISK IS DOING NOTHING
    37      00 02		WRITE_PROC	EQU	002H	; DISK IS IN A WRITE PROCESS, EXPECTING DATA FROM CPU
    38      00 04		READ_PROC	EQU	004H	; DISK IS IN A READ PROCESS, SENDING DATA TO CPU
    39      00 08		WAITING 	EQU	008H	; DISK IS WAITING FOR A START FRAME OR IDLE COMMAND
    40
    41 			;******************************************************************************
    42 			;
    43 			; POTENTIAL HDD ERROR CONDITIONS
    44 			;
    45 			;******************************************************************************
    46
    47      00 E0		HDD_REFUSE_IDLE EQU	0E0H	; OCCURS WHEN THE DISK WILL NOT ENTER AN IDLE STATE; LIKELY THE DISK IS FAULTY
    27
    28 			;***********************************************************************
    29 			;
    30 			; ADDRESS MACROS FOR BIOS
    31 			;
    32 			;***********************************************************************
    33
    34      00 00		BIOS_BASE	  EQU 0000H
    35      04 00		BIOS_SIZE	  EQU 0400H
    36
    37      04 00		BIOS_VAR_BASE	  EQU BIOS_BASE + BIOS_SIZE
    38      00 80		BIOS_VAR_SIZE	  EQU 0080H
    39
    40      04 80		INPUT_BUFFER_BASE EQU BIOS_VAR_BASE + BIOS_VAR_SIZE
    41      01 00		INPUT_BUFFER_SIZE EQU 0100H
    42
    43      01 00		SYS_STACK_SIZE	  EQU 00100H
    44      06 80		SYS_STACK_BASE	  EQU INPUT_BUFFER_BASE+INPUT_BUFFER_SIZE+SYS_STACK_SIZE
    45
    46      06 81		VIDEO_MEMORY_BASE EQU SYS_STACK_BASE+1
    47      50 00		VIDEO_MEMORY_SIZE EQU 5000H
    48
    49      56 81		OS_LOADER_BASE	  EQU VIDEO_MEMORY_BASE+VIDEO_MEMORY_SIZE
    50      02 00		OS_LOADER_SIZE	  EQU 0200H
    51
    52      58 81		BIOS_EXTENTION	  EQU OS_LOADER_BASE+OS_LOADER_SIZE
    53
    54 			;***********************************************************************
    55 			;
    56 			; PORT MACROS FOR I/O OPERATIONS
    57 			;
    58 			;***********************************************************************
    59
    60      00 01		VIDEO_MODE_PORT EQU 01H
    61      00 02		TEXT_OPER_PORT	EQU 02H
    62      00 03		TEXT_OUT_PORT	EQU 03H
    63
    64      00 04		KEY_INPUT_PORT	EQU 04H
    65
    66      00 05		HDD_RX_PORT	EQU 05H
    67      00 06		HDD_TX_PORT	EQU 06H
    68
    69      00 0A		BANK_PORT	EQU 0AH
    70
    71 			;***********************************************************************
    72 			;
    73 			; HARD DRIVE STATUS MACROS
    74 			;
    75 			;***********************************************************************
    76
    77      00 00		HDD_IDLE	EQU 000H    ; HARD DRIVE IS IDLING
    78      00 FF		HDD_CMD_ERROR	EQU 0FFH    ; INVALID ADDRESS
    79      00 01		HDD_NEED_DATA	EQU 001H    ; WAITING FOR BYTE
    80      00 FE		HDD_WRITE_ERROR EQU 0FEH    ; WRITING ERROR
    81      00 02		HDD_HAVE_DATA	EQU 002H    ; WAITING FOR CPU TO READ BYTE
    82      00 FD		HDD_READ_ERROR	EQU 0FDH    ; READING ERROR
    83      00 03		HDD_WRITE_DONE	EQU 003H    ; WRITE IS DONE
    84      00 04		HDD_READ_DONE	EQU 004H    ; READ IS DONE
    85
    86 			;***********************************************************************
    87 			;
    88 			; HARD DRIVE COMMANDS
    89 			;
    90 			;***********************************************************************
    91
    92      00 00		HDD_ENTER_IDLE	EQU 000H    ; FORCES IDLE
    93      00 01		HDD_START_WRITE EQU 001H    ; STARTS WRITING SECTOR TO ADDRESS
    94      00 FE		HDD_END_WRITE	EQU 0FEH    ; TERMINATES WRITE
    95      00 02		HDD_START_READ	EQU 002H    ; STARTS READING SECTOR
    96      00 FD		HDD_END_READ	EQU 0FDH    ; TERMINATES READ
    97      00 03		HDD_READ_BYTE	EQU 003H    ; SIGNALS HARD DISK TO READ THE NEXT BYTE
    98      00 04		HDD_SEND_BYTE	EQU 004H    ; SIGNALS HARD DISK TO SEND THE NEXT BYTE
    99
   100 			;***********************************************************************
   101 			;
   102 			; KEYBOARD MACROS
   103 			;
   104 			;***********************************************************************
   105
   106      00 00		TRIGGER_RETURN	EQU 00H
   107      00 01		TRIGGER_KEYDOWN EQU 01H
   108
   109      00 00		POLLING_MODE	EQU 00H
   110      00 01		INTERRUPT_MODE	EQU 01H
   111
   112 			;***********************************************************************
   113 			;
   114 			; VIDEO MACROS
   115 			;
   116 			;***********************************************************************
   117
   118      00 00		DELETE_CHAR	EQU 00H
   119      00 01		APPEND_CHAR	EQU 01H
   120      00 02		NEW_LINE	EQU 02H
   121      00 03		RESET_SCREEN	EQU 03H
   122
   123      00 00		HI_RES_MODE	EQU 00H
   124      00 01		LO_RES_MODE	EQU 01H
   125      00 02		TEXT_MODE	EQU 02H
   126
   127 			;***********************************************************************
   128 			;
   129 			; NOP FILLS BETWEEN INTERRUPT VECTORS
   130 			; IT'S TOO MUCH WORK TO TRY TO WORK AROUND THEM
   131 			; AND MAKES UGLY CODE
   132 			;
   133 			;***********************************************************************
   134
   135     		INT_FILL_HALF	MACRO
   136     				NOP
   137     				NOP
   138     				NOP
   139     				NOP
   140     				NOP
   141     				NOP
   142     				ENDM
   143
   144
   145     		INT_FILL	MACRO
   146     				INT_FILL_HALF
   147     				INT_FILL_HALF
   148     				NOP
   149     				ENDM
   150
   151
   152 			;***********************************************************************
   153 			;
   154 			; INTERRUPT VECTOR JUMP TABLE
   155 			;
   156 			; BY DEFAULT: 00 - BIOS_START
   157 			;	      08 - KEYBOARD_INTERRUPT
   158 			;	      10 -
   159 			;	      18 -
   160 			;	      20 -
   161 			;	      28 -
   162 			;	      30 -
   163 			;	      38 -
   164 			;
   165 			;***********************************************************************
   166
   167      00 00			ORG BIOS_BASE
   168
   169 0000 C3 0F 02		JMP ENTRY
   170
   171     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0003 00				NOP
     3 0004 00				NOP
     4 0005 00				NOP
     5 0006 00				NOP
     6 0007 00				NOP
     7 0008 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0009 00				NOP
     3 000A 00				NOP
     4 000B 00				NOP
     5 000C 00				NOP
     6 000D 00				NOP
     7 000E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 000F 00				NOP
     5 			;\------------- INT_FILL end
   172
   173 0010 C3 91 00		JMP KEYBOARD_INT
   174
   175     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0013 00				NOP
     3 0014 00				NOP
     4 0015 00				NOP
     5 0016 00				NOP
     6 0017 00				NOP
     7 0018 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0019 00				NOP
     3 001A 00				NOP
     4 001B 00				NOP
     5 001C 00				NOP
     6 001D 00				NOP
     7 001E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 001F 00				NOP
     5 			;\------------- INT_FILL end
   176
   177 0020 C3 73 00		JMP NULL_INTERRUPT
   178
   179     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0023 00				NOP
     3 0024 00				NOP
     4 0025 00				NOP
     5 0026 00				NOP
     6 0027 00				NOP
     7 0028 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0029 00				NOP
     3 002A 00				NOP
     4 002B 00				NOP
     5 002C 00				NOP
     6 002D 00				NOP
     7 002E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 002F 00				NOP
     5 			;\------------- INT_FILL end
   180
   181 0030 C3 73 00		JMP NULL_INTERRUPT
   182
   183     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0033 00				NOP
     3 0034 00				NOP
     4 0035 00				NOP
     5 0036 00				NOP
     6 0037 00				NOP
     7 0038 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0039 00				NOP
     3 003A 00				NOP
     4 003B 00				NOP
     5 003C 00				NOP
     6 003D 00				NOP
     7 003E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 003F 00				NOP
     5 			;\------------- INT_FILL end
   184
   185 0040 C3 73 00		JMP NULL_INTERRUPT
   186
   187     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0043 00				NOP
     3 0044 00				NOP
     4 0045 00				NOP
     5 0046 00				NOP
     6 0047 00				NOP
     7 0048 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0049 00				NOP
     3 004A 00				NOP
     4 004B 00				NOP
     5 004C 00				NOP
     6 004D 00				NOP
     7 004E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 004F 00				NOP
     5 			;\------------- INT_FILL end
   188
   189 0050 C3 73 00		JMP NULL_INTERRUPT
   190
   191     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0053 00				NOP
     3 0054 00				NOP
     4 0055 00				NOP
     5 0056 00				NOP
     6 0057 00				NOP
     7 0058 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0059 00				NOP
     3 005A 00				NOP
     4 005B 00				NOP
     5 005C 00				NOP
     6 005D 00				NOP
     7 005E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 005F 00				NOP
     5 			;\------------- INT_FILL end
   192
   193 0060 C3 73 00		JMP NULL_INTERRUPT
   194
   195     			INT_FILL
     1 			;/------------- INT_FILL start
     2     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0063 00				NOP
     3 0064 00				NOP
     4 0065 00				NOP
     5 0066 00				NOP
     6 0067 00				NOP
     7 0068 00				NOP
     8 			;\------------- INT_FILL_HALF end
     3     				INT_FILL_HALF
     1 			;/------------- INT_FILL_HALF start
     2 0069 00				NOP
     3 006A 00				NOP
     4 006B 00				NOP
     5 006C 00				NOP
     6 006D 00				NOP
     7 006E 00				NOP
     8 			;\------------- INT_FILL_HALF end
     4 006F 00				NOP
     5 			;\------------- INT_FILL end
   196
   197 0070 C3 73 00		JMP NULL_INTERRUPT
   198
   199
   200 			NULL_INTERRUPT:
   201 0073 C9			RET
   202
   203
   204 			;***********************************************************************
   205 			;
   206 			; FUNCTION:  SWITCH_BANK
   207 			; PARAMS:    BANK NUMBER IN A
   208 			; RETURNS:   NONE
   209 			; NOTES:     SWITCHES THE MEMORY BANK. BE PREPARED.
   210 			; PROC TIME: 20 CYCLES
   211 			;
   212 			;***********************************************************************
   213
   214 			SWITCH_BANK:
   215 0074 D3 0A			OUT BANK_PORT
   216 0076 C9			RET
   217
   218 			;***********************************************************************
   219 			;
   220 			; FUNCTION:  SET_VIDE0_MODE
   221 			; PARAMS:    MODE CODE IN A
   222 			; RETURNS:   MODE SENT IN A
   223 			; NOTES:     CHANGES THE DISPLAY MODE
   224 			; PROC TIME: 27 CYCLES
   225 			;
   226 			;***********************************************************************
   227
   228 			SET_VIDEO_MODE:
   229 0077 E6 03			ANI 011B
   230 0079 D3 01			OUT VIDEO_MODE_PORT
   231 007B C9			RET
   232
   233 			;***********************************************************************
   234 			;
   235 			; FUNCTION:  SET_INPUT_MODE
   236 			; PARAMS:    MODE CODE IN A
   237 			; RETURNS:   MODE SENT
   238 			; NOTES:     CHANGES THE INPUT MODE TO EITHER INTERRUPT OR POLLING
   239 			; PROC TIME: 5702 CYCLES
   240 			;
   241 			;***********************************************************************
   242
   243 			SET_INPUT_MODE:
   244 007C E6 01			ANI  01H
   245 007E 32 01 04		STA  INPUT_MODE
   246
   247
   248 			;***********************************************************************
   249 			;
   250 			; FUNCTION:  ZERO_INPUT_BUFFER
   251 			; PARAMS:    NONE
   252 			; RETURNS:   NONE
   253 			; NOTES:     ZEROS THE BUFFER AND COUNTERS
   254 			; PROC TIME: 5682 CYCLES
   255 			;
   256 			;***********************************************************************
   257
   258 			ZERO_INPUT_BUFFER:
   259 0081 AF			XRA  A
   260 0082 32 02 04		STA  BUFFER_INDEX
   261 0085 32 03 04		STA  PROCESSED_INDEX
   262 0088 21 80 04		LXI  H,INPUT_BUFFER
   263 			LOOP_ZERO_BUFFER:
   264 008B 77			MOV  M,A
   265 008C 2C			INR  L
   266 008D C2 8B 00		JNZ  LOOP_ZERO_BUFFER
   267 0090 C9			RET
   268
   269 			;***********************************************************************
   270 			;
   271 			; FUNCTION:  KEYBOARD_INT
   272 			; PARAMS:    NONE
   273 			; RETURNS:   KEY PRESSED
   274 			; NOTES:     TRIGGERED WHENEVER A KEY IS PRESSED
   275 			;	     IF IN INTERRUPT MODE, ADDS KEY TO THE BUFFER
   276 			;	     IF IN POLLING MODE, THE STATE OF THE KEY IS TOGGLED
   277 			; PROC TIME: 158-216 CYCLES
   278 			;
   279 			;***********************************************************************
   280
   281 			KEYBOARD_INT:
   282 0091 F5			PUSH PSW	     ; ENTER INTERRUPT
   283 0092 C5			PUSH B
   284 0093 D5			PUSH D
   285 0094 E5			PUSH H
   286 0095 21 80 04		LXI  H,INPUT_BUFFER  ; LOAD H WITH BUFFER ADDRESS
   287 0098 3A 01 04		LDA  INPUT_MODE      ; TEST IF WE'RE IN INTERRUPT MODE
   288 009B B7			ORA  A
   289 009C CA B3 00		JZ   TOGGLE_STATE    ; IF WE'RE NOT, THEN GO TO POLLING MODE
   290 009F DB 04			IN   KEY_INPUT_PORT  ; IF WE ARE, GET KEY PRESSED
   291 00A1 FE 80			CPI  10000000B	     ; IF KEY PRESSED > 127 THAN IT'S SIGNALING BEING RELEASED
   292 00A3 F2 BB 00		JP   EXIT_INTERRUPT  ; WE DON'T RECORD RELEASES IN INTERRUPT MODE SO EXIT
   293 00A6 47			MOV  B,A	     ; IF RECORDING, SAVE CHAR IN B
   294 00A7 3A 02 04		LDA  BUFFER_INDEX    ; LOAD A WITH INDEX
   295 00AA 6F			MOV  L,A	     ; BECAUSE THE BUFFER IS AT 0300H, WE JUST MOVE A INTO L
   296 00AB 3C			INR  A		     ; INCREMENT TO NEXT MEMORY LOCATION
   297 00AC 32 02 04		STA  BUFFER_INDEX    ; STORE MEMORY LOCATION FOR NEXT CALL
   298 00AF 70			MOV  M,B	     ; STORE CHAR
   299 00B0 C3 BB 00		JMP  EXIT_INTERRUPT
   300
   301 			TOGGLE_STATE:
   302 00B3 DB 04			IN   KEY_INPUT_PORT  ; GET KEY PRESSED
   303 00B5 E6 7F			ANI  01111111B	     ; IGNORE STATE, AS TOGGLING HANDLES THIS
   304 00B7 6F			MOV  L,A
   305 00B8 7E			MOV  A,M
   306 00B9 2F			CMA		     ; TOGGLE KEY STATE
   307 00BA 77			MOV  M,A
   308
   309 			;***********************************************************************
   310 			;
   311 			; FUNCTION:  EXIT_INTERRUPT
   312 			; PARAMS:    NONE
   313 			; RETURNS:   NONE
   314 			; NOTES:     RESTORES THE STATE OF ALL REGISTERS FROM ENTER_INTERRUPT
   315 			; PROC TIME: 50 CYCLES
   316 			;
   317 			;***********************************************************************
   318 			EXIT_INTERRUPT:
   319 00BB E1			POP  H
   320 00BC D1			POP  D
   321 00BD C1			POP  B
   322 00BE F1			POP  PSW
   323 00BF C9			RET
   324
   325 			;***********************************************************************
   326 			;
   327 			; FUNCTION:  GETKEY
   328 			; PARAMS:    IF IN POLLING MODE, THEN KEY IN A
   329 			;	     IF IN INTERRUPT MODE, THEN NONE
   330 			; RETURNS:   IF IN POLLING MODE, STATE OF KEY IN A
   331 			;	     OTHERWISE NEXT KEY IN BUFFER IN A OR -1 IF NO KEYS PRESSED
   332 			; NOTES:
   333 			; PROC TIME: 62/93 CYCLES
   334 			;
   335 			;***********************************************************************
   336
   337 			GETKEY:
   338 00C0 21 80 04		LXI H,INPUT_BUFFER    ; LOAD HL WITH BUFFER ADDRESS
   339 00C3 47			MOV B,A 	      ; STORE CHAR IN B INCASE WE'RE IN POLLING MODE
   340 00C4 3A 01 04		LDA INPUT_MODE	      ; CHECK IF WE'RE IN INTERRUPT MODE
   341 00C7 B7			ORA A
   342 00C8 CA DD 00		JZ  GET_STATE	      ; IF NOT GO TO GET THE KEY STATE
   343 00CB 3A 03 04		LDA PROCESSED_INDEX   ; LOAD CURRENT INDEX OF PROCESSED KEYS
   344 00CE 6F			MOV L,A 	      ; STORE IN LOWER ADDRESS
   345 00CF 3A 02 04		LDA BUFFER_INDEX      ; LOAD INDEX OF UNPROCESSED KEYS
   346 00D2 BD			CMP L
   347 00D3 3E FF			MVI A,0FFH
   348 00D5 C8			RZ		      ; IF WE'RE AT THE SAME INDEX, NO KEYS HAVE BEEN PRESSED
   349 00D6 7D			MOV A,L
   350 00D7 3C			INR A
   351 00D8 32 03 04		STA PROCESSED_INDEX   ; STORE THE NEXT INDEX
   352 00DB 7E			MOV A,M 	      ; LOAD A WITH KEY PRESSED
   353 00DC C9			RET		      ; GTFO
   354
   355 			GET_STATE:
   356 00DD 68			MOV L,B 	      ; MOVE INDEX OF KEY TO LOWER ADDRESS
   357 00DE 7E			MOV A,M 	      ; GET KEY STATE
   358 00DF C9			RET
   359
   360 			;***********************************************************************
   361 			;
   362 			; FUNCTION:  BACKSPACE
   363 			; PARAMS:    NONE
   364 			; RETURNS:   -1 IF NOT IN TEXT MODE
   365 			; NOTES:     DELETES THE PREVIOUS CHARACTER
   366 			; PROC TIME: 28/59 CYCLES
   367 			;
   368 			;***********************************************************************
   369
   370 			BACKSPACE:
   371 00E0 DB 01			IN  VIDEO_MODE_PORT
   372 00E2 FE 02			CPI TEXT_MODE
   373 00E4 3E FF			MVI A,0FFH
   374 00E6 C0			RNZ
   375 00E7 3E 00			MVI A,DELETE_CHAR
   376 00E9 D3 02			OUT TEXT_OPER_PORT
   377 00EB D3 03			OUT TEXT_OUT_PORT
   378 00ED C9			RET
   379
   380 			;***********************************************************************
   381 			;
   382 			; FUNCTION:  NEWLINE
   383 			; PARAMS:    NONE
   384 			; RETURNS:   -1 IF NOT IN TEXT MODE
   385 			; NOTES:     GOES TO NEXT LINE IN DISPLAY
   386 			; PROC TIME: 28/59 CYCLES
   387 			;
   388 			;***********************************************************************
   389
   390 			NEWLINE:
   391 00EE DB 01			IN  VIDEO_MODE_PORT
   392 00F0 FE 02			CPI TEXT_MODE
   393 00F2 3E FF			MVI A,0FFH
   394 00F4 C0			RNZ
   395 00F5 3E 02			MVI A,NEW_LINE
   396 00F7 D3 02			OUT TEXT_OPER_PORT
   397 00F9 D3 03			OUT TEXT_OUT_PORT
   398 00FB C9			RET
   399
   400 			;***********************************************************************
   401 			;
   402 			; FUNCTION:  RESET_CURSOR
   403 			; PARAMS:    NONE
   404 			; RETURNS:   -1 IN A IF NOT IN TEXT MODE, ELSE NONE
   405 			; NOTES:     SETS CURSOR TO 0
   406 			; PROC TIME: 28/63 CYCLES
   407 			;
   408 			;***********************************************************************
   409
   410 			RESET_CURSOR:
   411 00FC DB 01			IN  VIDEO_MODE_PORT
   412 00FE FE 02			CPI TEXT_MODE
   413 0100 3E FF			MVI A,0FFH
   414 0102 C0			RNZ
   415 0103 3E 03			MVI A,RESET_SCREEN
   416 0105 D3 02			OUT TEXT_OPER_PORT
   417 0107 AF			XRA A
   418 0108 D3 03			OUT TEXT_OUT_PORT
   419 010A C9			RET
   420
   421 			;***********************************************************************
   422 			;
   423 			; FUNCTION:  DISPCHAR
   424 			; PARAMS:    CHAR TO DISPLAY IN A
   425 			; RETURNS:   CHAR DISPLAYED OR -1 IF NOT IN TEXT MODE
   426 			; NOTES:     DISPLAYS CHARACTER TO SCREEN AT CURSOR POSITION THEN
   427 			;	     INCREMENTS CURSOR
   428 			; PROC TIME: 45-110 CYCLES
   429 			;
   430 			;***********************************************************************
   431
   432 			DISPCHAR:
   433 010B FE 08			CPI 08H
   434 010D CA E0 00		JZ  BACKSPACE
   435 0110 FE 0A			CPI 0AH
   436 0112 CA EE 00		JZ  NEWLINE
   437 0115 47			MOV B,A
   438 0116 DB 01			IN  VIDEO_MODE_PORT
   439 0118 FE 02			CPI TEXT_MODE
   440 011A 3E FF			MVI A,0FFH
   441 011C C0			RNZ
   442 011D 3E 01			MVI A,APPEND_CHAR
   443 011F D3 02			OUT TEXT_OPER_PORT
   444 0121 78			MOV A,B
   445 0122 D3 03			OUT TEXT_OUT_PORT
   446 0124 C9			RET
   447
   448 			;***********************************************************************
   449 			;
   450 			; FUNCTION:  PRINT
   451 			; PARAMS:    BASE OF NULL-TERMINATED STRING IN HL
   452 			; RETURNS:   0 IN A IF SUCCESSFUL
   453 			; NOTES:
   454 			; PROC TIME: 127*(STRLEN+1) + 69
   455 			;
   456 			;***********************************************************************
   457
   458 			PRINT:
   459 0125 7E			MOV  A,M
   460 0126 23			INX  H
   461 0127 CD 0B 01		CALL DISPCHAR
   462 012A B7			ORA  A
   463 012B C2 25 01		JNZ  PRINT
   464 012E C3 E0 00		JMP  BACKSPACE
   465 				
   466 			;***********************************************************************
   467 			;
   468 			; FUNCTION:  GETCHAR
   469 			; PARAMS:    NONE
   470 			; RETURNS:   CHARACTER CODE OF INPUT KEY
   471 			; NOTES:     WAITS FOR A KEY TO GET PRESSED AND DISPLAYS IT TO SCREEN
   472 			; PROC TIME:
   473 			;
   474 			;***********************************************************************	
   475
   476 			GETCHAR:
   477 0131 CD C0 00		CALL GETKEY
   478 0134 FE FF			CPI  0FFH
   479 0136 CA 31 01		JZ   GETCHAR
   480 0139 C3 0B 01		JMP  DISPCHAR
   481
   482 			;***********************************************************************
   483 			;
   484 			; FUNCTION:  GETCH
   485 			; PARAMS:    NONE
   486 			; RETURNS:   CHARACTER CODE OF INPUT KEY
   487 			; NOTES:     RETURNS KEY PRESSED WITHOUT ECHO
   488 			; PROC TIME:
   489 			;
   490 			;***********************************************************************
   491
   492 			GETCH:
   493 013C CD C0 00		CALL GETKEY
   494 013F FE FF			CPI  0FFH
   495 0141 CA 3C 01		JZ   GETCH
   496 0144 C9			RET
   497
   498 			;***********************************************************************
   499 			;
   500 			; FUNCTION:  READ_SECTOR
   501 			; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
   502 			; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
   503 			; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
   504 			;				 C C C C C C C H  |  H H S S S S S S
   505 			;	     THIS IS THE CORE READ OPERATION, WHICH SHOULD ONLY
   506 			;	     BE PERFORMED UNDER THE DISGRESSION OF THE OS.
   507 			; PROC TIME: BEST CASE: 30883 CYCLES
   508 			;
   509 			;***********************************************************************
   510
   511 			READ_SECTOR:
   512 0145 F3			DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
   513 0146 3E 06			MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
   514 0148 D3 06			OUT  HDD_TX_PORT
   515 014A DB 05			IN   HDD_RX_PORT
   516 014C FE 01			CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
   517 014E CA 64 01		JZ   READ_SEC00     ; IT IS IDLE, SO PERFORM READ
   518 0151 3E 01			MVI  A,ENTER_IDLE   ; FORCE TO IDLE
   519 0153 D3 06			OUT  HDD_TX_PORT
   520 0155 3E 06			MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
   521 0157 D3 06			OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
   522 0159 DB 05			IN   HDD_RX_PORT    ; GET STATUS
   523 015B FE 01			CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
   524 015D CA 64 01		JZ   READ_SEC00     ; CONTINUE
   525 0160 FB			EI		    ; RE-ENABLE INTERRUPTS
   526 0161 3E E0			MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
   527 0163 C9			RET			; RETURN
   528 			READ_SEC00:
   529 0164 3E 03			MVI  A,REQUEST_READ ; REQUEST READ OPERATION
   530 0166 D3 06			OUT  HDD_TX_PORT
   531 0168 DB 05			IN   HDD_RX_PORT    ; GET RESPONSE
   532 016A FE 07			CPI  ACKNOWLEDGE    ; ? - ACK
   533 016C C2 B1 01		JNZ  READ_ERR	    ; N - RETURN
   534 016F 3E 04			MVI  A,START_FRAME  ; SEND A START FRAME
   535 0171 D3 06			OUT  HDD_TX_PORT
   536 0173 7A			MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
   537 0174 D3 06			OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
   538 0176 7B			MOV  A,E	    ; MOVE IN LOWER 8 BITS
   539 0177 D3 06			OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
   540 0179 3E 05			MVI  A,END_FRAME    ; END FRAME
   541 017B D3 06			OUT  HDD_TX_PORT    ; SEND
   542 017D DB 05			IN   HDD_RX_PORT    ;
   543 017F FE 04			CPI  START_FRAME    ; ? - START FRAME
   544 0181 C2 B1 01		JNZ  READ_ERR	    ; N - RETURN
   545 0184 11 00 02		LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
   546 			READ_SEC10:
   547 0187 DB 05			IN   HDD_RX_PORT    ; READ A BYTE
   548 0189 77			MOV  M,A	    ; STORE BYTE IN BUFFER
   549 018A 23			INX  H		    ; INCREMENT BUFFER PTR
   550 018B 1D			DCR  E		    ; DECREMENT E
   551 018C C2 87 01		JNZ  READ_SEC10     ; RELOOP IF != 0
   552 018F 15			DCR  D		    ; DECREMENT D AS WELL
   553 0190 C2 87 01		JNZ  READ_SEC10     ; RELOOP IF != 0
   554 0193 DB 05			IN   HDD_RX_PORT    ; READ WHAT SHOULD BE AN END_FRAME
   555 0195 FE 05			CPI  END_FRAME	    ; ? - WHAT WE EXPECT
   556 0197 C2 B1 01		JNZ  READ_ERR	    ; N - RETURN
   557 019A 3E 07			MVI  A,ACKNOWLEDGE  ; LOAD ACK
   558 019C D3 06			OUT  HDD_TX_PORT    ; SEND ACK
   559 019E DB 05			IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
   560 01A0 FE 09			CPI  READ_OKAY	    ; ENSURE THE READ IS OKAY
   561 01A2 C2 B1 01		JNZ  READ_ERR	    ; RETURN IF NOT
   562 01A5 3E 01			MVI  A,ENTER_IDLE   ;
   563 01A7 D3 06			OUT  HDD_TX_PORT    ; SEND COMMAND TO IDLE
   564 01A9 DB 05			IN   HDD_RX_PORT    ; SHOULD RECIEVE IDLE
   565 01AB FE 01			CPI  IDLE	    ; ? - WHAT WE EXPECT
   566 01AD C2 B1 01		JNZ  READ_ERR	    ; N - RETURN EARLY
   567 01B0 AF			XRA  A		    ; ZERO RETURN VALUE
   568 			READ_ERR:
   569 01B1 FB			EI		    ; ENABLE INTERRUPTS
   570 01B2 C9			RET		    ; RETURN
   571
   572 			;***********************************************************************
   573 			;
   574 			; FUNCTION:  WRITE_SECTOR
   575 			; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
   576 			; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
   577 			; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
   578 			;				 C C C C C C C H  |  H H S S S S S S
   579 			;	     THIS IS THE CORE WRITE OPERATION, WHICH SHOULD ONLY
   580 			;	     BE PERFORMED UNDER THE DISGRESSION OF THE OS.
   581 			; PROC TIME: BEST CASE: 30883 CYCLES
   582 			;
   583 			;***********************************************************************
   584
   585 			WRITE_SECTOR:
   586 01B3 F3			DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
   587 01B4 3E 06			MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
   588 01B6 D3 06			OUT  HDD_TX_PORT
   589 01B8 DB 05			IN   HDD_RX_PORT
   590 01BA FE 01			CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
   591 01BC CA D2 01		JZ   WRITE_SEC00    ; IT IS IDLE, SO PERFORM WRITE
   592 01BF 3E 01			MVI  A,ENTER_IDLE   ; FORCE TO IDLE
   593 01C1 D3 06			OUT  HDD_TX_PORT
   594 01C3 3E 06			MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
   595 01C5 D3 06			OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
   596 01C7 DB 05			IN   HDD_RX_PORT    ; GET STATUS
   597 01C9 FE 01			CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
   598 01CB CA D2 01		JZ   WRITE_SEC00    ; CONTINUE
   599 01CE FB			EI		    ; RE-ENABLE INTERRUPTS
   600 01CF 3E E0			MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
   601 01D1 C9			RET			; RETURN
   602 			WRITE_SEC00:
   603 01D2 3E 02			MVI  A,REQUEST_WRITE; REQUEST READ OPERATION
   604 01D4 D3 06			OUT  HDD_TX_PORT
   605 01D6 DB 05			IN   HDD_RX_PORT    ; GET RESPONSE
   606 01D8 FE 07			CPI  ACKNOWLEDGE    ; ? - ACK
   607 01DA C2 0D 02		JNZ  WRITE_ERR	    ; N - RETURN
   608 01DD 3E 04			MVI  A,START_FRAME  ; SEND A START FRAME
   609 01DF D3 06			OUT  HDD_TX_PORT
   610 01E1 7A			MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
   611 01E2 D3 06			OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
   612 01E4 7B			MOV  A,E	    ; MOVE IN LOWER 8 BITS
   613 01E5 D3 06			OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
   614 01E7 11 00 02		LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
   615 			WRITE_SEC10:
   616 01EA 7E			MOV  A,M	    ; LOAD BYTE INTO A
   617 01EB 23			INX  H		    ; GO TO NEXT BYTE IN BUFFER
   618 01EC D3 06			OUT  HDD_TX_PORT    ; WRITE BYTE
   619 01EE 1D			DCR  E		    ; DECREMENT E
   620 01EF C2 EA 01		JNZ  WRITE_SEC10    ; RELOOP IF != 0
   621 01F2 15			DCR  D		    ; DECREMENT D AS WELL
   622 01F3 C2 EA 01		JNZ  WRITE_SEC10    ; RELOOP IF != 0
   623 01F6 3E 05			MVI  A,END_FRAME    ; SEND ENDFRAME
   624 01F8 D3 06			OUT  HDD_TX_PORT    ; WRITE TO DISK
   625 01FA DB 05			IN   HDD_RX_PORT    ; READ WHAT SHOULD BE A WRITE_OKAY
   626 01FC FE 08			CPI  WRITE_OKAY     ; ? - WHAT WE EXPECT
   627 01FE C2 0D 02		JNZ  WRITE_ERR	    ; N - RETURN
   628 0201 3E 01			MVI  A,ENTER_IDLE   ; TELL IT TO IDLE
   629 0203 D3 06			OUT  HDD_TX_PORT    ; SEND IDLE
   630 0205 DB 05			IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
   631 0207 FE 01			CPI  IDLE	    ; ENSURE IT IS IDLE
   632 0209 C2 0D 02		JNZ  WRITE_ERR	    ; RETURN IF NOT
   633 020C AF			XRA  A		    ; ZERO RETURN VALUE
   634 			WRITE_ERR:
   635 020D FB			EI		    ; ENABLE INTERRUPTS
   636 020E C9			RET		    ; RETURN
   637
   638 			;***********************************************************************
   639 			;
   640 			; FUNCTION:  ENTRY
   641 			; PARAMS:    NONE
   642 			; RETURNS:   NONE
   643 			; NOTES:     ATTEMPTS TO LOAD OS. IF FAILS, A BASIC TERMINAL IS STARTED
   644 			; PROC TIME: BEST CASE: 30883 CYCLES
   645 			;
   646 			;***********************************************************************
   647
   648 			;***********************************************************************
   649 			;
   650 			; FUNCTION:  HARDWARE_TEST
   651 			; PARAMS:    NONE
   652 			; RETURNS:   0 IF SUCCESSFUL, OTHERWISE ERROR CODE IN A
   653 			; NOTES:     TESTS EVERYTHING EVER.
   654 			; PROC TIME:
   655 			;
   656 			;***********************************************************************
   657
   658 			ENTRY:
   659 020F 31 80 06		LXI  SP,SYS_STACK      ; LOAD STACK POINTER
   660 0212 FB			EI
   661 0213 3E 00			MVI  A,000H
   662 0215 32 75 08		STA  VIDEO_MEMORY_BASE+500
   663 0218 76			HLT
   664 0219 3E 02			MVI  A,TEXT_MODE       ; SET DISPLAY TO TEXT MODE
   665 021B CD 77 00		CALL SET_VIDEO_MODE
   666 021E 3E 01			MVI  A,INTERRUPT_MODE
   667 0220 CD 7C 00		CALL SET_INPUT_MODE    ; SET INPUT TO INTERRUPT MODE
   668 0223 FB			EI		       ; ENABLE INTERRUPTS FOR INPUT
   669 0224 21 7E 02		LXI  H,INIT_DATA
   670 0227 CD 25 01		CALL PRINT
   671 022A CD 25 01		CALL PRINT	       ; DISPLAY STEP ONE, INITIALIZING REGISTERS
   672 022D 21 81 56		LXI  H,OS_LOADER_BASE
   673 0230 11 00 00		LXI  D,0000H
   674 0233 CD 45 01		CALL READ_SECTOR       ; LOAD 512 BYTE OS LOADER
   675 0236 11 01 00		LXI  D,0001H	       ; LOAD SECTOR 1 ADDR INTO DE
   676 0239 21 7D 04		LXI  H,INIT_DATA+511   ; FUCKIN DATA
   677 023C 3E 41			MVI  A,041H
   678 023E 77			MOV  M,A
   679 023F 21 7E 02		LXI  H,INIT_DATA
   680 0242 CD B3 01		CALL WRITE_SECTOR      ; TEST THIS BITCH
   681 0245 21 C7 02		LXI  H,PERIOD
   682 0248 CD 25 01		CALL PRINT	       ; DISPLAY STEP TWO WAS SUCCESSFUL
   683 024B 76			HLT
   684 024C 21 81 56		LXI  H,OS_LOADER_BASE
   685 024F 11 FE 01		LXI  D,01FEH	       ; MOVE TO LAST TWO BYTES LOADED
   686 0252 19			DAD  D
   687 0253 7E			MOV  A,M
   688 0254 FE FF			CPI  0FFH	       ; THE LAST TWO BYTES SHOULD BE 0XFF, 0XAA
   689 0256 C2 74 02		JNZ  LOAD_ERROR        ; SO HERE WE TEST FOR THAT, AND IF THEY AREN'T
   690 0259 E5			PUSH H		       ; WE GO TO OUR MINIMALIST COMMAND LINE
   691 025A 21 C7 02		LXI  H,PERIOD
   692 025D CD 25 01		CALL PRINT
   693 0260 E1			POP  H
   694 0261 23			INX  H
   695 0262 7E			MOV  A,M
   696 0263 FE AA			CPI  0AAH
   697 0265 C2 74 02		JNZ  LOAD_ERROR
   698 0268 21 C7 02		LXI  H,PERIOD
   699 026B CD 25 01		CALL PRINT
   700 026E CD FC 00		CALL RESET_CURSOR
   701 0271 C3 81 56		JMP  OS_LOADER_BASE
   702
   703 			LOAD_ERROR:
   704 0274 21 CA 02		LXI  H,LOAD_ERROR_MSG
   705 0277 CD 25 01		CALL PRINT
   706 027A 76			HLT
   707 027B C3 81 58		JMP  BIOS_EXTENTION
   708
   709 			INIT_DATA:
   710 027E			DB  0AH, 0AH, '                          DANS PC',0
            0A 0A 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            44 41 4E 53 
            20 50 43 00 
            
   711 02A2			DB  0AH,      '                         LOADING OS',0
            0A 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 4C 4F 
            41 44 49 4E 
            47 20 4F 53 
            00 
   712 			PERIOD:
   713 02C7			DB  '. ',0
            2E 20 00 
   714 			LOAD_ERROR_MSG:
   715 02CA			DB  0AH,      '                       ERROR LOADING OS',0
            0A 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            20 20 20 20 
            45 52 52 4F 
            52 20 4C 4F 
            41 44 49 4E 
            47 20 4F 53 
            00 
   716
   717      04 00			ORG BIOS_VAR_BASE
   718
   719 			TRIGGER_MODE:
   720 0400			DS 1
   721 			INPUT_MODE:
   722 0401			DS 1
   723 			BUFFER_INDEX:
   724 0402			DS 1
   725 			PROCESSED_INDEX:
   726 0403			DS 1
   727
   728      04 80			ORG INPUT_BUFFER_BASE
   729 			INPUT_BUFFER:
   730
   731      06 80			ORG SYS_STACK_BASE
   732 			SYS_STACK:


*******************************************************************************
                                 Symbols table
*******************************************************************************

Names			Types	Values
-----			-----	------
ENTER_IDLE		EQU	00001h
REQUEST_WRITE		EQU	00002h
REQUEST_READ		EQU	00003h
START_FRAME		EQU	00004h
END_FRAME		EQU	00005h
STATUS			EQU	00006h
ACKNOWLEDGE		EQU	00007h
WRITE_OKAY		EQU	00008h
READ_OKAY		EQU	00009h
WRITE_ERROR		EQU	000F0h
READ_ERROR		EQU	000F1h
NACK_ERROR		EQU	000F2h
PROC_ERROR		EQU	000F3h
IDLE			EQU	00001h
WRITE_PROC		EQU	00002h
READ_PROC		EQU	00004h
WAITING			EQU	00008h
HDD_REFUSE_IDLE		EQU	000E0h
BIOS_BASE		EQU	00000h
BIOS_SIZE		EQU	00400h
BIOS_VAR_BASE		EQU	00400h
BIOS_VAR_SIZE		EQU	00080h
INPUT_BUFFER_BASE	EQU	00480h
INPUT_BUFFER_SIZE	EQU	00100h
SYS_STACK_SIZE		EQU	00100h
SYS_STACK_BASE		EQU	00680h
VIDEO_MEMORY_BASE	EQU	00681h
VIDEO_MEMORY_SIZE	EQU	05000h
OS_LOADER_BASE		EQU	05681h
OS_LOADER_SIZE		EQU	00200h
BIOS_EXTENTION		EQU	05881h
VIDEO_MODE_PORT		EQU	00001h
TEXT_OPER_PORT		EQU	00002h
TEXT_OUT_PORT		EQU	00003h
KEY_INPUT_PORT		EQU	00004h
HDD_RX_PORT		EQU	00005h
HDD_TX_PORT		EQU	00006h
BANK_PORT		EQU	0000Ah
HDD_IDLE		EQU	00000h
HDD_CMD_ERROR		EQU	000FFh
HDD_NEED_DATA		EQU	00001h
HDD_WRITE_ERROR		EQU	000FEh
HDD_HAVE_DATA		EQU	00002h
HDD_READ_ERROR		EQU	000FDh
HDD_WRITE_DONE		EQU	00003h
HDD_READ_DONE		EQU	00004h
HDD_ENTER_IDLE		EQU	00000h
HDD_START_WRITE		EQU	00001h
HDD_END_WRITE		EQU	000FEh
HDD_START_READ		EQU	00002h
HDD_END_READ		EQU	000FDh
HDD_READ_BYTE		EQU	00003h
HDD_SEND_BYTE		EQU	00004h
TRIGGER_RETURN		EQU	00000h
TRIGGER_KEYDOWN		EQU	00001h
POLLING_MODE		EQU	00000h
INTERRUPT_MODE		EQU	00001h
DELETE_CHAR		EQU	00000h
APPEND_CHAR		EQU	00001h
NEW_LINE		EQU	00002h
RESET_SCREEN		EQU	00003h
HI_RES_MODE		EQU	00000h
LO_RES_MODE		EQU	00001h
TEXT_MODE		EQU	00002h
NULL_INTERRUPT		Label	00073h
SWITCH_BANK		Label	00074h
SET_VIDEO_MODE		Label	00077h
SET_INPUT_MODE		Label	0007Ch
ZERO_INPUT_BUFFER	Label	00081h
LOOP_ZERO_BUFFER	Label	0008Bh
KEYBOARD_INT		Label	00091h
TOGGLE_STATE		Label	000B3h
EXIT_INTERRUPT		Label	000BBh
GETKEY			Label	000C0h
GET_STATE		Label	000DDh
BACKSPACE		Label	000E0h
NEWLINE			Label	000EEh
RESET_CURSOR		Label	000FCh
DISPCHAR		Label	0010Bh
PRINT			Label	00125h
GETCHAR			Label	00131h
GETCH			Label	0013Ch
READ_SECTOR		Label	00145h
READ_SEC00		Label	00164h
READ_SEC10		Label	00187h
READ_ERR		Label	001B1h
WRITE_SECTOR		Label	001B3h
WRITE_SEC00		Label	001D2h
WRITE_SEC10		Label	001EAh
WRITE_ERR		Label	0020Dh
ENTRY			Label	0020Fh
LOAD_ERROR		Label	00274h
INIT_DATA		Label	0027Eh
PERIOD			Label	002C7h
LOAD_ERROR_MSG		Label	002CAh
TRIGGER_MODE		Label	00400h
INPUT_MODE		Label	00401h
BUFFER_INDEX		Label	00402h
PROCESSED_INDEX		Label	00403h
INPUT_BUFFER		Label	00480h
SYS_STACK		Label	00680h

Statistics
----------
"Name"	= 0
"EQU"	= 64
"SET"	= 0
Labels	= 37


