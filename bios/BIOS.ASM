;***********************************************************************
;
; BASIC INPUT/OUTPUT SYSTEM FOR THE DPC BASED AROUND THE INTEL 8080
; MICRO-PROCESSOR. THIS PROVIDES THE VERY BASIC ROUTINES FOR
; INTERFACING WITH THE ENVIRONMENT. THIS INCLUDES KEYBOARD INPUT,
; TEXT AND GRAPHICS DISPLAY, MEMORY BANKING, AND DISK I/O.
; THERE IS NO SECONDARY PROCESSOR TO HANDLE I/O, AS I AM SHOOTING FOR
; SIMPLICITY NOT PERFORMANCE.
;
;***********************************************************************

;***********************************************************************
;
; REGISTERS ARE SAVED BY THE CALLER. THE CALLER ONLY NEEDS TO SAVE
; REGISTERS THAT IT SEES FIT.
;
; ALL REGISTERS MAY BE USED BY THE CALLEE
;
; ARGS ARE PASSED THROUGH REGISTERS AND ON TOP OF STACK
; (MOST 8-BIT VALUES ARE RETURNED THROUGH A AND 16-BIT VALUES IN HL)
;
; THE CALLEE IS RESPONSIBLE FOR STACK CLEAN UP
;
;***********************************************************************

	INCLUDE	"HDD.INC"

;***********************************************************************
;
; ADDRESS MACROS FOR BIOS
;
;***********************************************************************

BIOS_BASE	  EQU 0000H
BIOS_SIZE	  EQU 0500H

BIOS_VAR_BASE	  EQU BIOS_BASE + BIOS_SIZE
BIOS_VAR_SIZE	  EQU 0100H

INPUT_BUFFER_BASE EQU BIOS_VAR_BASE + BIOS_VAR_SIZE
INPUT_BUFFER_SIZE EQU 0100H

SYS_STACK_SIZE	  EQU 00100H
SYS_STACK_BASE	  EQU INPUT_BUFFER_BASE+INPUT_BUFFER_SIZE+SYS_STACK_SIZE-1

VIDEO_MEMORY_BASE EQU SYS_STACK_BASE
VIDEO_MEMORY_SIZE EQU 5000H

OS_LOADER_BASE	  EQU VIDEO_MEMORY_BASE+VIDEO_MEMORY_SIZE+1
OS_LOADER_SIZE	  EQU 0200H

OS_BASE 		  EQU OS_LOADER_BASE+OS_LOADER_SIZE

;***********************************************************************
;
; PORT MACROS FOR I/O OPERATIONS
;
;***********************************************************************

VIDEO_MODE_PORT EQU 01H
TEXT_OPER_PORT	EQU 02H
TEXT_OUT_PORT	EQU 03H

KEY_INPUT_PORT	EQU 04H

HDD_RX_PORT	EQU 05H
HDD_TX_PORT	EQU 06H

BANK_PORT	EQU 0AH

;***********************************************************************
;
; KEYBOARD MACROS
;
;***********************************************************************

TRIGGER_RETURN	EQU 00H
TRIGGER_KEYDOWN EQU 01H

POLLING_MODE	EQU 00H
INTERRUPT_MODE	EQU 01H

;***********************************************************************
;
; VIDEO MACROS
;
;***********************************************************************

DELETE_CHAR		EQU 00H
APPEND_CHAR		EQU 01H
NEW_LINE		EQU 02H
RESET_SCREEN	EQU 03H

HI_RES_MODE	EQU 00H
LO_RES_MODE	EQU 01H
TEXT_MODE	EQU 02H

;***********************************************************************
;
; NOP FILLS BETWEEN INTERRUPT VECTORS
; IT'S TOO MUCH WORK TO TRY TO WORK AROUND THEM
; AND MAKES UGLY CODE
;
;***********************************************************************

INT_FILL_HALF	MACRO
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		ENDM


INT_FILL	MACRO
		INT_FILL_HALF
		INT_FILL_HALF
		NOP
		ENDM
		
INT_ENTER   MACRO
		PUSH PSW
		PUSH B
		PUSH D
		PUSH H
		ENDM
		
INT_EXIT	MACRO
		POP  H
		POP  D
		POP  B
		POP  PSW
		RET
		ENDM


;***********************************************************************
;
; INTERRUPT VECTOR JUMP TABLE
;
; BY DEFAULT: 00 - BIOS_START
;	      08 - KEYBOARD_INTERRUPT
;	      10 -
;	      18 -
;	      20 -
;	      28 -
;	      30 -
;	      38 -
;
;***********************************************************************

	ORG BIOS_BASE

	JMP ENTRY

	INT_FILL

	JMP KEYBOARD_INT

	INT_FILL

	JMP NULL_INTERRUPT

	INT_FILL

	JMP NULL_INTERRUPT

	INT_FILL

	JMP NULL_INTERRUPT

	INT_FILL

	JMP NULL_INTERRUPT

	INT_FILL

	JMP NULL_INTERRUPT

	INT_FILL

	JMP NULL_INTERRUPT


NULL_INTERRUPT:
	RET


;***********************************************************************
;
; FUNCTION:  SWITCH_BANK
; PARAMS:    BANK NUMBER IN A (1-7)
; RETURNS:   NONE
; NOTES:     SWITCHES THE MEMORY BANK. BE PREPARED.
; PROC TIME: 20 CYCLES
;
;***********************************************************************

SWITCH_BANK:
	OUT BANK_PORT
	RET
	

;***********************************************************************
;
; FUNCTION:  GET_BANK
; PARAMS:    NONE
; RETURNS:   BANK NUMBER IN A (1-7)
; NOTES:     RETURNS THE CURRENT MEMORY BANK
; PROC TIME: 20 CYCLES
;
;***********************************************************************

GET_BANK:
	IN  BANK_PORT
	RET


;***********************************************************************
;
; FUNCTION:  SET_VIDE0_MODE
; PARAMS:    MODE CODE IN A
; RETURNS:   MODE SENT IN A
; NOTES:     CHANGES THE DISPLAY MODE
; PROC TIME: 27 CYCLES
;
;***********************************************************************

SET_VIDEO_MODE:
	ANI 011B
	OUT VIDEO_MODE_PORT
	RET

;***********************************************************************
;
; FUNCTION:  SET_INPUT_MODE
; PARAMS:    MODE CODE IN A
; RETURNS:   MODE SENT
; NOTES:     CHANGES THE INPUT MODE TO EITHER INTERRUPT OR POLLING
; PROC TIME: 5702 CYCLES
;
;***********************************************************************

SET_INPUT_MODE:
	ANI  01H
	STA  INPUT_MODE


;***********************************************************************
;
; FUNCTION:  ZERO_INPUT_BUFFER
; PARAMS:    NONE
; RETURNS:   NONE
; NOTES:     ZEROS THE BUFFER AND COUNTERS
; PROC TIME: 5682 CYCLES
;
;***********************************************************************

ZERO_INPUT_BUFFER:
	XRA  A
	STA  BUFFER_INDEX
	STA  PROCESSED_INDEX
	LXI  H,INPUT_BUFFER
LOOP_ZERO_BUFFER:
	MOV  M,A
	INR  L
	JNZ  LOOP_ZERO_BUFFER
	RET

;***********************************************************************
;
; FUNCTION:  KEYBOARD_INT
; PARAMS:    NONE
; RETURNS:   KEY PRESSED
; NOTES:     TRIGGERED WHENEVER A KEY IS PRESSED
;	     IF IN INTERRUPT MODE, ADDS KEY TO THE BUFFER
;	     IF IN POLLING MODE, THE STATE OF THE KEY IS TOGGLED
; PROC TIME: 158-216 CYCLES
;
;***********************************************************************

KEYBOARD_INT:
	INT_ENTER
	LXI  H,INPUT_BUFFER  ; LOAD H WITH BUFFER ADDRESS
	LDA  INPUT_MODE      ; TEST IF WE'RE IN INTERRUPT MODE
	ORA  A
	JZ   TOGGLE_STATE    ; IF WE'RE NOT, THEN GO TO POLLING MODE
	IN   KEY_INPUT_PORT  ; IF WE ARE, GET KEY PRESSED
	CPI  10000000B	     ; IF KEY PRESSED > 127 THAN IT'S SIGNALING BEING RELEASED
	JP   EXIT_INTERRUPT  ; WE DON'T RECORD RELEASES IN INTERRUPT MODE SO EXIT
	MOV  B,A	     ; IF RECORDING, SAVE CHAR IN B
	LDA  BUFFER_INDEX    ; LOAD A WITH INDEX
	MOV  L,A	     ; BECAUSE THE BUFFER IS AT 0300H, WE JUST MOVE A INTO L
	INR  A		     ; INCREMENT TO NEXT MEMORY LOCATION
	STA  BUFFER_INDEX    ; STORE MEMORY LOCATION FOR NEXT CALL
	MOV  M,B	     ; STORE CHAR
	JMP	 EXIT_INTERRUPT

TOGGLE_STATE:
	IN   KEY_INPUT_PORT  ; GET KEY PRESSED
	ANI  01111111B	     ; IGNORE STATE, AS TOGGLING HANDLES THIS
	MOV  L,A
	MOV  A,M
	CMA		     ; TOGGLE KEY STATE
	MOV  M,A
EXIT_INTERRUPT:
	INT_EXIT

;***********************************************************************
;
; FUNCTION:  GETKEY
; PARAMS:    IF IN POLLING MODE, THEN KEY IN A
;	     IF IN INTERRUPT MODE, THEN NONE
; RETURNS:   IF IN POLLING MODE, STATE OF KEY IN A
;	     OTHERWISE NEXT KEY IN BUFFER IN A OR -1 IF NO KEYS PRESSED
; NOTES:
; PROC TIME: 62/93 CYCLES
;
;***********************************************************************

GETKEY:
	LXI H,INPUT_BUFFER    ; LOAD HL WITH BUFFER ADDRESS
	MOV B,A 	      ; STORE CHAR IN B INCASE WE'RE IN POLLING MODE
	LDA INPUT_MODE	      ; CHECK IF WE'RE IN INTERRUPT MODE
	ORA A
	JZ  GET_STATE	      ; IF NOT GO TO GET THE KEY STATE
	LDA PROCESSED_INDEX   ; LOAD CURRENT INDEX OF PROCESSED KEYS
	MOV L,A 	      ; STORE IN LOWER ADDRESS
	LDA BUFFER_INDEX      ; LOAD INDEX OF UNPROCESSED KEYS
	CMP L
	MVI A,0FFH
	RZ		      ; IF WE'RE AT THE SAME INDEX, NO KEYS HAVE BEEN PRESSED
	MOV A,L
	INR A
	STA PROCESSED_INDEX   ; STORE THE NEXT INDEX
	MOV A,M 	      ; LOAD A WITH KEY PRESSED
	RET		      ; GTFO

GET_STATE:
	MOV L,B 	      ; MOVE INDEX OF KEY TO LOWER ADDRESS
	MOV A,M 	      ; GET KEY STATE
	RET

;***********************************************************************
;
; FUNCTION:  BACKSPACE
; PARAMS:    NONE
; RETURNS:   -1 IF NOT IN TEXT MODE
; NOTES:     DELETES THE PREVIOUS CHARACTER
; PROC TIME: 28/59 CYCLES
;
;***********************************************************************

BACKSPACE:
	IN  VIDEO_MODE_PORT
	CPI TEXT_MODE
	MVI A,0FFH
	RNZ
	MVI A,DELETE_CHAR
	OUT TEXT_OPER_PORT
	OUT TEXT_OUT_PORT
	RET

;***********************************************************************
;
; FUNCTION:  NEWLINE
; PARAMS:    NONE
; RETURNS:   -1 IF NOT IN TEXT MODE
; NOTES:     GOES TO NEXT LINE IN DISPLAY
; PROC TIME: 28/59 CYCLES
;
;***********************************************************************

NEWLINE:
	IN  VIDEO_MODE_PORT
	CPI TEXT_MODE
	MVI A,0FFH
	RNZ
	MVI A,NEW_LINE
	OUT TEXT_OPER_PORT
	OUT TEXT_OUT_PORT
	RET

;***********************************************************************
;
; FUNCTION:  RESET_CURSOR
; PARAMS:    NONE
; RETURNS:   -1 IN A IF NOT IN TEXT MODE, ELSE NONE
; NOTES:     SETS CURSOR TO 0 AND CLEARS SCREEN
; PROC TIME: 28/63 CYCLES
;
;***********************************************************************

RESET_CURSOR:
	IN  VIDEO_MODE_PORT
	CPI TEXT_MODE
	MVI A,0FFH
	RNZ
	MVI A,RESET_SCREEN
	OUT TEXT_OPER_PORT
	XRA A
	OUT TEXT_OUT_PORT
	RET

;***********************************************************************
;
; FUNCTION:  DISPCHAR
; PARAMS:    CHAR TO DISPLAY IN A
; RETURNS:   CHAR DISPLAYED OR -1 IF NOT IN TEXT MODE
; NOTES:     DISPLAYS CHARACTER TO SCREEN AT CURSOR POSITION THEN
;	     INCREMENTS CURSOR
; PROC TIME: 45-110 CYCLES
;
;***********************************************************************

DISPCHAR:
	CPI 08H
	JZ  BACKSPACE
	CPI 0AH
	JZ  NEWLINE
	MOV B,A
	IN  VIDEO_MODE_PORT
	CPI TEXT_MODE
	MVI A,0FFH
	RNZ
	MVI A,APPEND_CHAR
	OUT TEXT_OPER_PORT
	MOV A,B
	OUT TEXT_OUT_PORT
	RET

;***********************************************************************
;
; FUNCTION:  PRINT
; PARAMS:    BASE OF NULL-TERMINATED STRING IN HL
; RETURNS:   0 IN A IF SUCCESSFUL
; NOTES:
; PROC TIME: 127*(STRLEN+1) + 69
;
;***********************************************************************

PRINT:
	MOV  A,M
	INX  H
	CALL DISPCHAR
	ORA  A
	JNZ  PRINT
	JMP  BACKSPACE
	
;***********************************************************************
;
; FUNCTION:  GETCHAR
; PARAMS:    NONE
; RETURNS:   CHARACTER CODE OF INPUT KEY
; NOTES:     WAITS FOR A KEY TO GET PRESSED AND DISPLAYS IT TO SCREEN
; PROC TIME:
;
;***********************************************************************	

GETCHAR:
	CALL GETKEY
	CPI  0FFH
	JZ   GETCHAR
	JMP  DISPCHAR

;***********************************************************************
;
; FUNCTION:  GETCH
; PARAMS:    NONE
; RETURNS:   CHARACTER CODE OF INPUT KEY
; NOTES:     RETURNS KEY PRESSED WITHOUT ECHO
; PROC TIME:
;
;***********************************************************************

GETCH:
	CALL GETKEY
	CPI  0FFH
	JZ   GETCH
	RET

;***********************************************************************
;
; FUNCTION:  READ_SECTOR
; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
;						 C C C C C C C H  |  H H S S S S S S
;	     THIS IS THE CORE READ OPERATION, WHICH SHOULD ONLY
;	     BE PERFORMED UNDER THE DISGRESSION OF THE OS.
; PROC TIME: BEST CASE: 30883 CYCLES
;
;***********************************************************************

READ_SECTOR:
	DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
	MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
	OUT  HDD_TX_PORT
	IN   HDD_RX_PORT
	CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
	JZ   READ_SEC00     ; IT IS IDLE, SO PERFORM READ
	MVI  A,ENTER_IDLE   ; FORCE TO IDLE
	OUT  HDD_TX_PORT
	MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
	OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
	IN   HDD_RX_PORT    ; GET STATUS
	CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
	JZ   READ_SEC00     ; CONTINUE
	EI		    ; RE-ENABLE INTERRUPTS
	MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
	RET			; RETURN
READ_SEC00:
	MVI  A,REQUEST_READ ; REQUEST READ OPERATION
	OUT  HDD_TX_PORT
	IN   HDD_RX_PORT    ; GET RESPONSE
	CPI  ACKNOWLEDGE    ; ? - ACK
	JNZ  READ_ERR	    ; N - RETURN
	MVI  A,START_FRAME  ; SEND A START FRAME
	OUT  HDD_TX_PORT
	MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
	OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
	MOV  A,E	    ; MOVE IN LOWER 8 BITS
	OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
	MVI  A,END_FRAME    ; END FRAME
	OUT  HDD_TX_PORT    ; SEND
	IN   HDD_RX_PORT    ;
	CPI  START_FRAME    ; ? - START FRAME
	JNZ  READ_ERR	    ; N - RETURN
	LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
READ_SEC10:
	IN   HDD_RX_PORT    ; READ A BYTE
	MOV  M,A	    ; STORE BYTE IN BUFFER
	INX  H		    ; INCREMENT BUFFER PTR
	DCR  E		    ; DECREMENT E
	JNZ  READ_SEC10     ; RELOOP IF != 0
	DCR  D		    ; DECREMENT D AS WELL
	JNZ  READ_SEC10     ; RELOOP IF != 0
	IN   HDD_RX_PORT    ; READ WHAT SHOULD BE AN END_FRAME
	CPI  END_FRAME	    ; ? - WHAT WE EXPECT
	JNZ  READ_ERR	    ; N - RETURN
	MVI  A,ACKNOWLEDGE  ; LOAD ACK
	OUT  HDD_TX_PORT    ; SEND ACK
	IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
	CPI  READ_OKAY	    ; ENSURE THE READ IS OKAY
	JNZ  READ_ERR	    ; RETURN IF NOT
	MVI  A,ENTER_IDLE   ;
	OUT  HDD_TX_PORT    ; SEND COMMAND TO IDLE
	IN   HDD_RX_PORT    ; SHOULD RECIEVE IDLE
	CPI  IDLE	    ; ? - WHAT WE EXPECT
	JNZ  READ_ERR	    ; N - RETURN EARLY
	XRA  A		    ; ZERO RETURN VALUE
READ_ERR:
	EI		    ; ENABLE INTERRUPTS
	RET		    ; RETURN

;***********************************************************************
;
; FUNCTION:  WRITE_SECTOR
; PARAMS:    16-BIT CHS ADDRESS IN DE AND BUFFER ADDRESS IN HL
; RETURNS:   0 IN A IF SUCCESSFUL, ERROR CODE OTHERWISE
; NOTES:     ADDRESS IS IN CHS: 	D	  |	   E
;						 C C C C C C C H  |  H H S S S S S S
;	     THIS IS THE CORE WRITE OPERATION, WHICH SHOULD ONLY
;	     BE PERFORMED UNDER THE DISGRESSION OF THE OS.
; PROC TIME: BEST CASE: 30883 CYCLES
;
;***********************************************************************

WRITE_SECTOR:
	DI		    ; DISABLE INTERRUPTS. NO ONE CAN CUT IN DURING DISK IO
	MVI  A,STATUS	    ; CHECK THE STATUS OF THE DISK
	OUT  HDD_TX_PORT
	IN   HDD_RX_PORT
	CPI  IDLE	    ; ENSURE THAT IT IS IN IDLE STATE
	JZ   WRITE_SEC00    ; IT IS IDLE, SO PERFORM WRITE
	MVI  A,ENTER_IDLE   ; FORCE TO IDLE
	OUT  HDD_TX_PORT
	MVI  A,STATUS	    ; REQUEST TO VIEW STATUS AGAIN
	OUT  HDD_TX_PORT    ; DISREGARD PREVIOUS RETURN FROM ENTER_IDLE
	IN   HDD_RX_PORT    ; GET STATUS
	CPI  IDLE	    ; ENSURE IT IS NOW IN IDLE STATE
	JZ   WRITE_SEC00    ; CONTINUE
	EI		    ; RE-ENABLE INTERRUPTS
	MVI  A,HDD_REFUSE_IDLE	; LOAD ERROR CODE
	RET			; RETURN
WRITE_SEC00:
	MVI  A,REQUEST_WRITE; REQUEST READ OPERATION
	OUT  HDD_TX_PORT
	IN   HDD_RX_PORT    ; GET RESPONSE
	CPI  ACKNOWLEDGE    ; ? - ACK
	JNZ  WRITE_ERR	    ; N - RETURN
	MVI  A,START_FRAME  ; SEND A START FRAME
	OUT  HDD_TX_PORT
	MOV  A,D	    ; MOVE UPPER 8 BITS INTO A
	OUT  HDD_TX_PORT    ; SEND UPPER 8 BITS OF ADDRESS
	MOV  A,E	    ; MOVE IN LOWER 8 BITS
	OUT  HDD_TX_PORT    ; SEND LOWER 8 BITS
	LXI  DE,512	    ; LOAD DE WITH COUNT (512, OR LRECL)
WRITE_SEC10:
	MOV  A,M	    ; LOAD BYTE INTO A
	INX  H		    ; GO TO NEXT BYTE IN BUFFER
	OUT  HDD_TX_PORT    ; WRITE BYTE
	DCR  E		    ; DECREMENT E
	JNZ  WRITE_SEC10    ; RELOOP IF != 0
	DCR  D		    ; DECREMENT D AS WELL
	JNZ  WRITE_SEC10    ; RELOOP IF != 0
	MVI  A,END_FRAME    ; SEND ENDFRAME
	OUT  HDD_TX_PORT    ; WRITE TO DISK
	IN   HDD_RX_PORT    ; READ WHAT SHOULD BE A WRITE_OKAY
	CPI  WRITE_OKAY     ; ? - WHAT WE EXPECT
	JNZ  WRITE_ERR	    ; N - RETURN
	MVI  A,ENTER_IDLE   ; TELL IT TO IDLE
	OUT  HDD_TX_PORT    ; SEND IDLE
	IN   HDD_RX_PORT    ; RECEIEVE RESPONSE
	CPI  IDLE	    ; ENSURE IT IS IDLE
	JNZ  WRITE_ERR	    ; RETURN IF NOT
	XRA  A		    ; ZERO RETURN VALUE
WRITE_ERR:
	EI		    ; ENABLE INTERRUPTS
	RET		    ; RETURN

;***********************************************************************
;
; FUNCTION:  ENTRY
; PARAMS:    NONE
; RETURNS:   NONE
; NOTES:     ATTEMPTS TO LOAD OS. IF FAILS, A BASIC TERMINAL IS STARTED
; PROC TIME: BEST CASE: 30883 CYCLES
;
;***********************************************************************

;***********************************************************************
;
; FUNCTION:  HARDWARE_TEST
; PARAMS:    NONE
; RETURNS:   0 IF SUCCESSFUL, OTHERWISE ERROR CODE IN A
; NOTES:     TESTS EVERYTHING EVER.
; PROC TIME:
;
;***********************************************************************

ENTRY:
	LXI  SP,SYS_STACK      ; LOAD STACK POINTER
	MVI  A,TEXT_MODE       ; SET DISPLAY TO TEXT MODE
	CALL SET_VIDEO_MODE
	MVI  A,INTERRUPT_MODE
	CALL SET_INPUT_MODE    ; SET INPUT TO INTERRUPT MODE
	EI		       ; ENABLE INTERRUPTS FOR INPUT
	LXI  H,INIT_DATA
	CALL PRINT
	CALL PRINT
	CALL PRINT	       ; DISPLAY STEP ONE, INITIALIZING REGISTERS
	LXI  H,OS_LOADER_BASE
	LXI  D,0000H
	CALL READ_SECTOR       ; LOAD 512 BYTE OS LOADER
	LXI  H,PERIOD
	CALL PRINT	       ; DISPLAY STEP TWO WAS SUCCESSFUL
	LXI  H,OS_LOADER_BASE
	LXI  D,01FEH	       ; MOVE TO LAST TWO BYTES LOADED
	DAD  D
	MOV  A,M
	CPI  0FFH	       ; THE LAST TWO BYTES SHOULD BE 0XFF, 0XAA
	JNZ  LOAD_ERROR        ; SO HERE WE TEST FOR THAT, AND IF THEY AREN'T
	PUSH H		       ; WE GO TO OUR EVENTUAL MINIMALIST COMMAND LINE
	LXI  H,PERIOD
	CALL PRINT
	POP  H
	INX  H
	MOV  A,M
	CPI  0AAH
	JNZ  LOAD_ERROR
	LXI  H,PERIOD
	CALL PRINT
	CALL RESET_CURSOR
	JMP  OS_LOADER_BASE	; GO TO OS LOADER

LOAD_ERROR:
	LXI  H,LOAD_ERROR_MSG
	CALL PRINT
	HLT

INIT_DATA:
	DB  0AH, 0AH, '                          DANS PC',0
	DB  0AH,      '                         LOADING OS',0
PERIOD:
	DB  '. ',0
LOAD_ERROR_MSG:
	DB  0AH,      '                       ERROR LOADING OS',0

	ORG BIOS_VAR_BASE

TRIGGER_MODE:
	DS 1
INPUT_MODE:
	DS 1
BUFFER_INDEX:
	DS 1
PROCESSED_INDEX:
	DS 1

	ORG INPUT_BUFFER_BASE
INPUT_BUFFER:

	ORG SYS_STACK_BASE
SYS_STACK: