;***********************************************************************
;
; REGISTERS ARE SAVED BY THE CALLER. THE CALLER ONLY NEEDS TO SAVE
; REGISTERS THAT IT SEES FIT.
;
; ALL REGISTERS MAY BE USED BY THE CALLEE
;
; ARGS ARE PASSED THROUGH REGISTERS AND ON TOP OF STACK
; (MOST 8-BIT VALUES ARE RETURNED THROUGH A AND 16-BIT VALUES IN HL)
;
; THE CALLEE IS RESPONSIBLE FOR STACK CLEAN UP
;
;***********************************************************************

OS_LOADER_BASE	EQU 5680H
OS_LOADER_SIZE	EQU 0200H
BASIC_BASE	EQU OS_LOADER_BASE+OS_LOADER_SIZE
BASIC_SIZE	EQU 1000H

SET_INPUT_MODE	EQU 0074H
SET_MEM_BANK	EQU 0079H
ZERO_INPUT_BUF	EQU 007CH
GET_KEY 	EQU 00BBH
GET_STATE	EQU 00D8H
DISPCHAR	EQU 0106H
GETCHAR 	EQU 0120H
GETCH		EQU 012BH
PRINT		EQU 0134H
SET_VIDEO_MODE	EQU 0140H
READ_SECTOR	EQU 0146H
WRITE_SECTOR	EQU 0182H

	ORG OS_LOADER_BASE
LOADENTR:
	LXI  H,BASIC_BASE
	LXI  D,0001H
	LXI  B,0200H
	MVI  C,8
LOADLP:
	PUSH B
	CALL READ_SECTOR
	POP  B
	DAD  B
	INX  D
	DCR  C
	JNZ  LOADLP
	JMP  BASIC_BASE

	DS   0FFH, 0AAH
	ORG  BASIC_BASE


;***********************************************************************
;
; FUNCTION:  BCDADD
; PARAMS:    ADDRESS OF BCD IN HL
; RETURNS:   SUM OF BCDACC AND BCD AT HL IN BCDACC
; NOTES:     ADDS TWO 32-BIT BCDS
; PROC TIME: 677-1048 CYCLES
;
;***********************************************************************

BCDADD:
	MVI C,4
	LXI D,BCDACC
	STC
	CMC		; EFFECTIVELY SET CARRY TO ZERO
ADDLOOP:
	LDAX D		; LOAD BYTE OF ACCUMULATOR
	ADC  M		; ADD BYTE AT HL
	DAA		; DECIMAL ADJUST FOR BCD
	STAX D		; STORE BACK IN ACCUMULATOR
	INX  D		;
	INX  H		;
	DCR  C
	JNZ  ADDLOOP	; LOOP FOR FOUR BYTES
	RET


;***********************************************************************
;
; FUNCTION:  BCDNEG
; PARAMS:    ADDRESS OF BCD IN HL
; RETURNS:   10'S COMPLEMENT OF BCD IN H
; NOTES:     NEGATES 4 BYTE BCD
; PROC TIME: 677-1048 CYCLES
;
;***********************************************************************

BCDNEG:
	MVI C,4
	MVI B,99H
NEGLOOP:
	MOV A,B
	SUB M
	MOV M,A
	INX H
	DCR C
	JNZ NEGLOOP
	DCX H
	DCX H
	DCX H
	DCX H
	RET


;***********************************************************************
;
; FUNCTION:  BCDSUB
; PARAMS:    ADDRESS OF BCD IN HL
; RETURNS:   DIFFERENCE OF BCDACC AND BCD AT HL IN BCDACC
; NOTES:     SUBTRACTS TWO 32-BIT BCDS
; PROC TIME: 677-1048 CYCLES
;
;***********************************************************************

BCDSUB:
	CALL BCDNEG
	CALL BCDADD
	LXI  H,BCDACC
	CALL BCDNEG
	MVI  C,4
	STC
	CMC
	MVI  A,1
	MVI  B,0
SUBLOOP:
	ADC  M
	DAA
	MOV  M,A
	MOV  A,B
	DCR  C
	JNZ  SUBLOOP
	RET


;***********************************************************************
;
; FUNCTION:  STR2BCD
; PARAMS:    ADDRESS OF STRING IN HL
; RETURNS:   ADDRESS OF BCD IN HL
; NOTES:     CONVERTS STRING TO A 32-BIT BCD (MAX VALUE OF 99,999,999)
; PROC TIME: 677-1048 CYCLES
;
;***********************************************************************

BCD2STR:


;***********************************************************************
;
; FUNCTION:  STR2BCD
; PARAMS:    ADDRESS OF STRING IN HL
; RETURNS:   ADDRESS OF BCD IN HL
; NOTES:     CONVERTS STRING TO A 32-BIT BCD (MAX VALUE OF 99,999,999)
; PROC TIME: 677-1048 CYCLES
;
;***********************************************************************

STR2BCD:
	LXI D,BCDUNPK+8 ; LOAD D WITH END OF UNPACKED AREA
	XCHG
	MVI C,8 	; NIBBLE COUNT
	MVI B,'0'
	LDAX D		; TEST FOR NEGATIVE SIGN
	CPI  '-'
	JNZ  CONVERT
	MVI  A,1	; IF THERE IS, SAVE A FLAG TO NEGATE NUMBER
	STA  BCDNEG
	INX  D		; MOVE TO NEXT CHAR IN THE STRING
CONVERT:
	LDAX D		; LOAD A WITH NEXT CHAR
	ORA  A		; IF ZERO
	JZ   FINCONV	; FINISH ZEROING WORK AREA AND PACK
	SUB  B		; GET TRUE VALUE
	JM   CONVERR	; IF LESS THAN 0, ERROR
	CPI  0AH	; IF GREATER THAN OR EQUAL TO 10
	JM   CONVERR	; ERROR
	MOV  M,A	; STORE A IN UNPACKED AREA
	INX  D		; INC STRING INDEX
	INX  H		; INC UNPACKED INDEX
	DCR  C		; DEC COUNTER TO ENSURE
	JNZ  CONVERT	; WE DON'T OVERFLOW
FINCONV:
	MOV  A,C	; LOAD A WITH REMAINING COUNT
	INR  A
ZEROLOOP:
	DCR  A		; CHECK IF COUNT IS ZERO
	JZ   STRTPACK	; IF SO, WE CAN START PACKING
	MVI  M,0	; SET LEADING ZERO
	INX  H
	JMP  ZEROLOOP
STRTPACK:
	MVI  C,4	; LOOP COUNTER
	LXI  H,BCDUNPK	; HL = UNPACKED AREA
	LXI  D,BCDPACK	; DE = PACKED AREA
PACKFN:
	MOV  B,M	; STORE FIRST BCD DIGIT IN B
	INX  H
	MOV  A,M	; STORE SECOND BCD DIGIT IN A
	INX  H		; GO TO NEXT TWO BCD DIGITS
	RLC		; SHIFT LOWER FOUR BITS UPWARDS
	RLC		; SHIFT
	RLC		; SHIFT
	RLC		; SHIFT
	ANA  B		; MERGE TWO BITS
	STAX D		; STORE IN PACKED AREA
	INX  D		; GO TO NEXT PACKED INDEX
	DCR  C		; DECREMENT COUNTER
	JNZ  PACKFN
	LXI  H,BCDPACK
	RET
CONVERR:
	RET

STMTJMPTB:
	DS 0
IFSTR:
	DB 'IF',0
	DB IFSTMT
THENSTR:
	DB 'THEN',0
	DB THENSTMT
ELSESTR:
	DB 'ELSE',0
	DB ELSESTMT
ENDSTR:
	DB 'END',0
	DB ENDSTMT
GOTOSTR:
	DB 'GOTO',0
	DB GOTOSTMT
GOSUBSTR:
	DB 'GOSUB',0
	DB GOSUBSTMT
RETSTR:
	DB 'RET',0
	DB RETSTMT
LABLESTR:
	DB 'LET',0
	DB LABELSTMT
RUNSTR:
	DB 'RUN',0
	DB RUNSTMT
PAUSESTR:
	DB 'PAUSE',0
	DB PAUSESTMT
PRINTSTR:
	DB 'PRINT',0
	DB PRINTSTMT
READSTR:
	DB 'READ',0
	DB READSTMT
WRITESTR:
	DB 'WRITE',0
	DB WRITESTMT

FNCTJMPTB:
	DS 0
RNDSTR:
	DB 'RND',0
	DB RNDFUNCT
INPUTSTR:
	DB 'INPUT',0
	DB INPFUNCT
ABSSTR:
	DB 'ABS',0
	DB ABSFUNCT
SQRTSTR:
	DB 'SQRT',0
	DB SQRTFUNCT

BCDUNPK:
	DS 8
BCDPACK:
	DS 4
BCDACC:
	DS 4
FACC:
	DS 4
VARSPACE:
	DS 26
PROGSPACE:
	DS 0