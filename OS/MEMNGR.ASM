
	INCLUDE "BIOS_MAP.INC"

MM_BASE	EQU	8000H

; BEING LITTLE ENDIAN, THE LOWER BYTE IS STORED IN THE LOWER MEMORY ADDRESS

MALLOC:
	LXI  H, MM_BASE		; MOVE BASE MEM ADDRESS INTO HL
	POP  D				; POP RETURN ADDRESS INTO D
	POP  B				; POP REQUESTED LENGTH INTO B
	PUSH B				; PUSH BACK
	PUSH D				; PUSH BACK TO RESTORE SP
	DI					; ATOMIC BLOCK CHECKING
CHECK_BLOCK:
	MOV  E, M			; LOAD LOWER BYTE INTO D
	INX  H
	MOV  D, M			; LOAD UPPER BYTE INTO E
	MOV  A, D			; 
	ANI  80H			; BLOCK FREE? (TOP BIT == 1)
	JNZ  CHECK_SIZE		; IF SO, CHECK SIZE
	DAD	 D				; IF NOT, MOVE HL TO NEXT BLOCK
	MOV	 A, E
	ORA  D				; CURRENT BLOCK LEN == 0?
	JNZ  CHECK_BLOCK	; IF NOT, CHECK NEXT BLOCK
	MOV	 M, B			; STORE UPPER LENGTH BYTE
	DCX  H				; 
	MOV  M, C			; STORE LOWER LENGTH BYTE
	INX  H				; 
	INX  H 				; INCREMENT TO USABLE SPACE
	EI					; ENABLE INTERRUPTS FOR SCHEDULER
	RET
	
CHECK_SIZE:
	XRA  D				; CLEAR FREE BIT IN UPPER LENGTH BYTE
	MOV  D, A			; MOVE LENGTH BYTE BACK TO D W/O FREE BIT SET
	CMP  B				; BLOCK < REQUEST?
	JM   NEXT_BLOCK		; IF SO, GO TO NEXT BLOCK
	JNZ  ALLOCATE		; IF BLOCK > REQUEST, ALLOCATE
	MOV  A, E			; IF BLOCK == REQUEST, CHECK LOWER BYTE
	CMP  C				; BLOCK >= REQUEST?
	JP   ALLOCATE		; IF SO WE ALLOCATE IT
NEXT_BLOCK:
	DAD  D				; MOVE HL TO NEXT BLOCK
	JMP  CHECK_BLOCK	; CHECK NEXT BLOCK LENGTH
ALLOCATE:
	MOV  M, D			; WRITE UPPER LENGTH BYTE W/O FREE BIT
	INX  H				; INCREMENT TO USABLE SPACE
	EI					; ENABLE INTERRUPTS FOR SCHEDULER
	RET					; RETURN


FREE:
	DI					; DISABLE INTERRUPTS
	DCX  H				; GO DOWN TO UPPER LENGTH BYTE
	MOV  A, M			; MOVE INTO A
	ORI  80H			; SET FREE BIT
	MOV  M, A           ; STORE BACK
	; SCAN FOR FREED MEMORY
	EI
	RET